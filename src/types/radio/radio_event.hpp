// src/radio/radio_event.hpp
#pragma once

#include <cstdint>
#include <memory>

#include "types/messages/message.hpp"

namespace loramesher {
namespace radio {

// Event types that can be generated by the radio
enum class RadioEventType {
    kReceived,          // Message received
    kTransmitted,       // Message transmitted successfully
    kTimeout,           // Reception/transmission timeout
    kCrcError,          // CRC check failed
    kPreambleDetected,  // Preamble detected during reception
    kSyncWordValid,     // Valid sync word detected
    kHeaderValid,       // Valid header received
    kHeaderError,       // Header CRC error
    kNoise,             // Noise floor detected
    kCadDone,           // Channel activity detection completed
    kCadDetected,       // Channel activity detected
    kRxError,           // Reception error
    kTxError            // Transmission error
};

// Class to encapsulate radio events and their associated messages
class RadioEvent {
   public:
    // Constructor for events with message
    RadioEvent(RadioEventType type, std::unique_ptr<BaseMessage> message)
        : type_(type), message_(std::move(message)) {}

    // Constructor for events without message
    explicit RadioEvent(RadioEventType type) : type_(type), message_(nullptr) {}

    // Prevent copying to avoid unintended message duplication
    RadioEvent(const RadioEvent&) = delete;
    RadioEvent& operator=(const RadioEvent&) = delete;

    // Allow moving
    RadioEvent(RadioEvent&&) = default;
    RadioEvent& operator=(RadioEvent&&) = default;

    // Getters
    RadioEventType getType() const { return type_; }

    const BaseMessage* getMessage() const { return message_.get(); }

    // Take ownership of the message
    std::unique_ptr<BaseMessage> TakeMessage() { return std::move(message_); }

    // RSSI and SNR setters and getters
    void setRssi(int8_t rssi) { rssi_ = rssi; }
    int8_t getRssi() const { return rssi_; }

    void setSnr(int8_t snr) { snr_ = snr; }
    int8_t getSnr() const { return snr_; }

    // Timestamp setters and getters
    void setTimestamp(uint32_t timestamp) { timestamp_ = timestamp; }
    uint32_t getTimestamp() const { return timestamp_; }

    // Check if event has a valid message
    bool HasMessage() const { return message_ != nullptr; }

    // Convert event type to string for logging/debugging
    static const char* EventTypeToString(RadioEventType type) {
        switch (type) {
            case RadioEventType::kReceived:
                return "Received";
            case RadioEventType::kTransmitted:
                return "Transmitted";
            case RadioEventType::kTimeout:
                return "Timeout";
            case RadioEventType::kCrcError:
                return "CRC Error";
            case RadioEventType::kPreambleDetected:
                return "Preamble Detected";
            case RadioEventType::kSyncWordValid:
                return "Sync Word Valid";
            case RadioEventType::kHeaderValid:
                return "Header Valid";
            case RadioEventType::kHeaderError:
                return "Header Error";
            case RadioEventType::kNoise:
                return "Noise Detected";
            case RadioEventType::kCadDone:
                return "CAD Done";
            case RadioEventType::kCadDetected:
                return "CAD Detected";
            case RadioEventType::kRxError:
                return "Reception Error";
            case RadioEventType::kTxError:
                return "Transmission Error";
            default:
                return "Unknown Event";
        }
    }

   private:
    RadioEventType type_;
    std::unique_ptr<BaseMessage>
        message_;             // Optional message associated with event
    int8_t rssi_ = 0;         // Received Signal Strength Indicator
    int8_t snr_ = 0;          // Signal-to-Noise Ratio
    uint32_t timestamp_ = 0;  // Event timestamp
};

// Factory functions for creating common events
inline std::unique_ptr<RadioEvent> CreateReceivedEvent(
    std::unique_ptr<BaseMessage> message, int8_t rssi, int8_t snr) {
    auto event = std::make_unique<RadioEvent>(RadioEventType::kReceived,
                                              std::move(message));
    event->setRssi(rssi);
    event->setSnr(snr);
    // event->setTimestamp(/* Get current timestamp */);
    return event;
}

inline std::unique_ptr<RadioEvent> CreateTransmittedEvent(
    std::unique_ptr<BaseMessage> message) {
    auto event = std::make_unique<RadioEvent>(RadioEventType::kTransmitted,
                                              std::move(message));
    // event->setTimestamp(/* Get current timestamp */);
    return event;
}

inline std::unique_ptr<RadioEvent> CreateTimeoutEvent() {
    auto event = std::make_unique<RadioEvent>(RadioEventType::kTimeout);
    // event->setTimestamp(/* Get current timestamp */);
    return event;
}

}  // namespace radio
}  // namespace loramesher