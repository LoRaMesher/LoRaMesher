<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoRaMesh Log Analyzer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .upload-section {
            border: 2px dashed #bdc3c7;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            background: #f8f9fa;
        }
        .upload-section.dragover {
            border-color: #3498db;
            background: #e8f4f8;
        }
        .file-input {
            margin: 20px 0;
        }
        .btn {
            background: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        .btn:hover {
            background: #2980b9;
        }
        .visualization-container {
            display: none;
            margin-top: 20px;
        }
        .tabs {
            display: flex;
            border-bottom: 2px solid #ecf0f1;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            background: #ecf0f1;
            border: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 4px 4px 0 0;
        }
        .tab.active {
            background: #3498db;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .timeline-container {
            width: 100%;
            border: 1px solid #ddd;
        }
        .timeline-controls {
            background: #f8f9fa;
            padding: 10px;
            border-bottom: 1px solid #ddd;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .timeline-controls label {
            font-weight: bold;
            color: #2c3e50;
        }
        .timeline-controls input[type="range"] {
            flex: 1;
            margin: 0 10px;
        }
        .timeline-controls button {
            background: #3498db;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .timeline-controls button:hover {
            background: #2980b9;
        }
        .timeline {
            width: 100%;
            height: 400px;
            overflow-x: auto;
            overflow-y: hidden;
            position: relative;
        }
        .timeline-content {
            position: relative;
            height: 100%;
            min-width: 100%;
        }
        .node-timeline {
            height: 100px;
            border-bottom: 1px solid #eee;
            position: relative;
        }
        .node-label {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-weight: bold;
            color: #2c3e50;
            width: 100px;
            z-index: 10;
            background: white;
            padding: 2px 5px;
        }
        .slot-bar {
            height: 30px;
            position: absolute;
            top: 15px;
            border-radius: 4px;
            color: white;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.85;
            border: 1px solid rgba(0,0,0,0.3);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        .message-indicator {
            height: 20px;
            position: absolute;
            top: 50px;
            border-radius: 10px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
            border: 2px solid rgba(0,0,0,0.4);
            min-width: 20px;
        }
        /* Transmitted messages (darker/saturated colors) */
        .message-tx { 
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }
        .message-beacon { 
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
        }
        .message-join { 
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }
        .message-control { 
            background: linear-gradient(135deg, #34495e, #2c3e50);
            color: white;
        }
        .message-routing { 
            background: linear-gradient(135deg, #e67e22, #d35400);
            color: white;
        }
        .message-system { 
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            color: white;
        }
        .message-unknown { 
            background: linear-gradient(135deg, #bdc3c7, #95a5a6);
            color: white;
        }

        /* Received messages (lighter/pastel colors) */
        .message-rx { 
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }
        .message-beacon-rx { 
            background: linear-gradient(135deg, #c39bd3, #bb8fce);
            color: white;
        }
        .message-join-rx { 
            background: linear-gradient(135deg, #7fb3d3, #6c9bd1);
            color: white;
        }
        .message-control-rx { 
            background: linear-gradient(135deg, #85929e, #7d8693);
            color: white;
        }
        .message-routing-rx { 
            background: linear-gradient(135deg, #f0b27a, #eb984e);
            color: white;
        }
        .message-system-rx { 
            background: linear-gradient(135deg, #b2babb, #a6acaf);
            color: white;
        }
        .message-unknown-rx { 
            background: linear-gradient(135deg, #d5dbdb, #cacfd2);
            color: white;
        }
        .message-indicator:hover {
            opacity: 1;
            transform: scaleY(1.2);
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            border-width: 2px;
        }
        .slot-bar:hover {
            opacity: 1;
            transform: scaleY(1.15);
            z-index: 100;
            box-shadow: 0 3px 12px rgba(0,0,0,0.4);
            border-width: 2px;
        }
        .slot-sleep { background: #95a5a6; }
        .slot-tx { background: #e74c3c; }
        .slot-rx { background: #27ae60; }
        .slot-sync_beacon_tx { background: #f39c12; }
        .slot-sync_beacon_rx { background: #f39c12; }
        .slot-discovery { background: #9b59b6; }
        .slot-discovery_rx { background: #9b59b6; }
        .slot-discovery_tx { background: #8e44ad; }
        .slot-control_tx { background: #e67e22; }
        .slot-control_rx { background: #d35400; }
        .slot-joining { background: #16a085; }
        .slot-data { background: #2980b9; }
        .network-graph {
            width: 100%;
            height: 500px;
            border: 1px solid #ddd;
        }
        .message-flow {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            overflow-y: auto;
        }
        .message-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
        }
        .message-time {
            font-family: monospace;
            color: #7f8c8d;
            margin-right: 15px;
            min-width: 100px;
        }
        .message-content {
            flex: 1;
        }
        .message-from {
            font-weight: bold;
            color: #e74c3c;
        }
        .message-to {
            font-weight: bold;
            color: #27ae60;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }
        .stat-label {
            color: #7f8c8d;
            margin-top: 5px;
        }
        .log-info {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .error {
            color: #e74c3c;
            background: #fdf2f2;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .legend-container {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        .legend-header {
            background: #e9ecef;
            padding: 12px 15px;
            cursor: pointer;
            font-weight: bold;
            color: #495057;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .legend-header:hover {
            background: #dee2e6;
        }
        .legend-content {
            padding: 15px;
            display: none;
        }
        .legend-content.show {
            display: block;
        }
        .legend-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .legend-section {
            background: white;
            border-radius: 6px;
            padding: 15px;
            border: 1px solid #e9ecef;
        }
        .legend-section h4 {
            margin: 0 0 12px 0;
            color: #495057;
            font-size: 14px;
            font-weight: bold;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .legend-color {
            width: 20px;
            height: 16px;
            border-radius: 3px;
            margin-right: 10px;
            border: 1px solid rgba(0,0,0,0.2);
        }
        .legend-text {
            font-size: 13px;
            color: #495057;
        }
        .toggle-icon {
            font-size: 12px;
            transition: transform 0.3s ease;
        }
        .toggle-icon.rotated {
            transform: rotate(180deg);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>LoRaMesh Log Analyzer</h1>
        
        <div class="upload-section" id="uploadSection">
            <h3>Upload Log File</h3>
            <p>Drag and drop a log file here or click to select</p>
            <input type="file" id="fileInput" accept=".txt,.log" style="display: none;">
            <button class="btn" onclick="document.getElementById('fileInput').click()">Select File</button>
        </div>

        <div class="visualization-container" id="visualizationContainer">
            <div class="log-info" id="logInfo"></div>
            
            <div class="legend-container">
                <div class="legend-header" onclick="toggleLegend()">
                    <span>üìä Message Type Color Legend</span>
                    <span class="toggle-icon" id="toggleIcon">‚ñº</span>
                </div>
                <div class="legend-content" id="legendContent">
                    <div class="legend-grid">
                        <div class="legend-section">
                            <h4>üì§ Transmitted Messages (Darker Colors)</h4>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #9b59b6, #8e44ad);"></div>
                                <span class="legend-text">SYNC_BEACON</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #3498db, #2980b9);"></div>
                                <span class="legend-text">JOIN_REQUEST/RESPONSE</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #e67e22, #d35400);"></div>
                                <span class="legend-text">ROUTE_TABLE</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #34495e, #2c3e50);"></div>
                                <span class="legend-text">CONTROL</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #e74c3c, #c0392b);"></div>
                                <span class="legend-text">DATA</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #95a5a6, #7f8c8d);"></div>
                                <span class="legend-text">SYSTEM</span>
                            </div>
                        </div>
                        <div class="legend-section">
                            <h4>üì• Received Messages (Lighter Colors)</h4>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #c39bd3, #bb8fce);"></div>
                                <span class="legend-text">SYNC_BEACON</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #7fb3d3, #6c9bd1);"></div>
                                <span class="legend-text">JOIN_REQUEST/RESPONSE</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #f0b27a, #eb984e);"></div>
                                <span class="legend-text">ROUTE_TABLE</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #85929e, #7d8693);"></div>
                                <span class="legend-text">CONTROL</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #27ae60, #229954);"></div>
                                <span class="legend-text">DATA</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #b2babb, #a6acaf);"></div>
                                <span class="legend-text">SYSTEM</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="tabs">
                <button class="tab active" onclick="showTab('timeline')">Timeline</button>
                <button class="tab" onclick="showTab('network')">Network</button>
                <button class="tab" onclick="showTab('messages')">Messages</button>
                <button class="tab" onclick="showTab('stats')">Statistics</button>
            </div>

            <div id="timeline" class="tab-content active">
                <h3>Slot Timeline</h3>
                <div class="timeline-container">
                    <div class="timeline-controls">
                        <label>Zoom:</label>
                        <button onclick="zoomOut()">-</button>
                        <input type="range" id="zoomSlider" min="1" max="100" value="10" oninput="updateZoom()">
                        <button onclick="zoomIn()">+</button>
                        <span id="zoomLevel">10x</span>
                        
                        <label style="margin-left: 20px;">Time Range:</label>
                        <input type="range" id="timeRangeSlider" min="0" max="100" value="0" oninput="updateTimeRange()">
                        <span id="timeRangeLabel">0ms - 1000ms</span>
                        
                        <button onclick="resetView()" style="margin-left: 20px;">Reset View</button>
                    </div>
                    <div class="timeline" id="slotTimeline">
                        <div class="timeline-content" id="timelineContent"></div>
                    </div>
                </div>
            </div>

            <div id="network" class="tab-content">
                <h3>Network Topology</h3>
                <div class="network-graph" id="networkGraph"></div>
            </div>

            <div id="messages" class="tab-content">
                <h3>Message Flow</h3>
                <div class="message-flow" id="messageFlow"></div>
            </div>

            <div id="stats" class="tab-content">
                <h3>Network Statistics</h3>
                <div class="stats-grid" id="statsGrid"></div>
            </div>
        </div>
    </div>

    <script>
        // MessageType mapping from message_type.hpp
        const MessageType = {
            ANY: 0x00,
            
            // Main categories (high nibble)
            DATA_MSG: 0x10,
            CONTROL_MSG: 0x20,
            ROUTING_MSG: 0x30,
            SYSTEM_MSG: 0x40,
            
            // Specific message types
            DATA: 0x11,
            
            ACK: 0x21,
            PING: 0x23,
            PONG: 0x24,
            
            HELLO: 0x31,
            ROUTE_TABLE: 0x32,
            
            SYNC: 0x41,
            JOIN_REQUEST: 0x42,
            JOIN_RESPONSE: 0x43,
            SLOT_REQUEST: 0x44,
            SLOT_ALLOCATION: 0x45,
            SYNC_BEACON: 0x46
        };

        // Message type name mapping
        const MessageTypeName = {
            [MessageType.ANY]: 'ANY',
            [MessageType.DATA]: 'DATA',
            [MessageType.ACK]: 'ACK',
            [MessageType.PING]: 'PING',
            [MessageType.PONG]: 'PONG',
            [MessageType.HELLO]: 'HELLO',
            [MessageType.ROUTE_TABLE]: 'ROUTE_TABLE',
            [MessageType.SYNC]: 'SYNC',
            [MessageType.JOIN_REQUEST]: 'JOIN_REQUEST',
            [MessageType.JOIN_RESPONSE]: 'JOIN_RESPONSE',
            [MessageType.SLOT_REQUEST]: 'SLOT_REQUEST',
            [MessageType.SLOT_ALLOCATION]: 'SLOT_ALLOCATION',
            [MessageType.SYNC_BEACON]: 'SYNC_BEACON'
        };

        // Helper functions for message type categorization
        function getMainType(type) {
            return type & 0xF0;
        }

        function getMessageTypeInfo(typeValue, direction = 'transmitted') {
            // Convert string to number if needed
            const numType = typeof typeValue === 'string' ? 
                (typeValue.startsWith('0x') ? parseInt(typeValue, 16) : parseInt(typeValue, 10)) : 
                typeValue;
            
            const typeName = MessageTypeName[numType];
            if (!typeName) {
                return { name: 'UNKNOWN', category: 'unknown', cssClass: direction === 'received' ? 'unknown-rx' : 'unknown' };
            }
            
            const mainType = getMainType(numType);
            let category, cssClass;
            
            switch (mainType) {
                case MessageType.DATA_MSG:
                    category = 'data';
                    cssClass = direction === 'received' ? 'tx' : 'tx'; // Keep tx for both for now
                    break;
                case MessageType.CONTROL_MSG:
                    category = 'control';
                    cssClass = direction === 'received' ? 'control-rx' : 'control';
                    break;
                case MessageType.ROUTING_MSG:
                    category = 'routing';
                    cssClass = direction === 'received' ? 'routing-rx' : 'routing';
                    break;
                case MessageType.SYSTEM_MSG:
                    category = 'system';
                    if (numType === MessageType.SYNC_BEACON) {
                        cssClass = direction === 'received' ? 'beacon-rx' : 'beacon';
                    } else if (numType === MessageType.JOIN_REQUEST || numType === MessageType.JOIN_RESPONSE) {
                        cssClass = direction === 'received' ? 'join-rx' : 'join';
                    } else {
                        cssClass = direction === 'received' ? 'system-rx' : 'system';
                    }
                    break;
                default:
                    category = 'unknown';
                    cssClass = direction === 'received' ? 'unknown-rx' : 'unknown';
            }
            
            return { name: typeName, category, cssClass };
        }

        class LogAnalyzer {
            constructor() {
                this.nodes = new Map();
                this.messages = [];
                this.events = [];
                this.timeRange = { start: 0, end: 0 };
                this.zoomLevel = 10;
                this.timeWindowStart = 0;
                this.timeWindowEnd = 0;
                this.pendingTransmission = null;
                this.setupEventListeners();
            }

            setupEventListeners() {
                const uploadSection = document.getElementById('uploadSection');
                const fileInput = document.getElementById('fileInput');

                uploadSection.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadSection.classList.add('dragover');
                });

                uploadSection.addEventListener('dragleave', () => {
                    uploadSection.classList.remove('dragover');
                });

                uploadSection.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadSection.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.processFile(files[0]);
                    }
                });

                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.processFile(e.target.files[0]);
                    }
                });
            }

            processFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        this.parseLog(e.target.result);
                        this.showVisualization();
                    } catch (error) {
                        this.showError('Error parsing log file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }

            parseLog(logContent) {
                const lines = logContent.split('\n');
                this.events = [];
                this.messages = [];
                this.nodes.clear();
                this.pendingTransmission = null;

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    // Parse timestamp and node info
                    const timestampMatch = line.match(/\[(\d+) ms\]/);
                    const nodeMatch = line.match(/\[0x([0-9A-Fa-f]+)\]/);
                    
                    if (timestampMatch) {
                        const timestamp = parseInt(timestampMatch[1]);
                        const nodeId = nodeMatch ? nodeMatch[1] : 'unknown';
                        
                        // Parse slot transitions
                        const slotMatch = line.match(/Slot (\d+) transition: type=(\w+)/);
                        if (slotMatch) {
                            const slotNum = parseInt(slotMatch[1]);
                            const slotType = slotMatch[2];
                            
                            this.events.push({
                                timestamp,
                                nodeId,
                                type: 'slot_transition',
                                slotNum,
                                slotType
                            });
                        }

                        // Parse message transmissions - handle "Sending message" pattern first
                        const sendingMatch = line.match(/Sending message to 0x([0-9A-Fa-f]+), type: (\d+)/);
                        if (sendingMatch) {
                            const messageTypeInfo = getMessageTypeInfo(sendingMatch[2], 'transmitted');
                            
                            // Store pending transmission with type info
                            this.pendingTransmission = {
                                timestamp,
                                nodeId,
                                to: sendingMatch[1],
                                messageTypeInfo
                            };
                        }

                        // Parse "Transmitting message from X to Y" pattern - try multiple variations
                        let transmitMatch = line.match(/Transmitting message from 0x([0-9A-Fa-f]+) to 0x([0-9A-Fa-f]+)/);
                        if (!transmitMatch) {
                            // Try without "to X" part
                            transmitMatch = line.match(/Transmitting message from 0x([0-9A-Fa-f]+)/);
                            if (transmitMatch) {
                                transmitMatch[2] = 'FFFF'; // Default to broadcast if no "to" specified
                            }
                        }
                        
                        if (transmitMatch) {
                            let messageTypeInfo = { name: 'UNKNOWN', category: 'unknown', cssClass: 'tx' };
                            
                            // Use pending transmission info if available and matches
                            if (this.pendingTransmission && 
                                this.pendingTransmission.nodeId === nodeId &&
                                Math.abs(this.pendingTransmission.timestamp - timestamp) < 100) {
                                messageTypeInfo = this.pendingTransmission.messageTypeInfo;
                                this.pendingTransmission = null; // Clear pending transmission
                            }
                            
                            // Add transmission indicator on sender node
                            this.messages.push({
                                timestamp,
                                from: transmitMatch[1],
                                to: transmitMatch[2],
                                type: messageTypeInfo.cssClass,
                                typeName: messageTypeInfo.name,
                                category: messageTypeInfo.category,
                                nodeId: transmitMatch[1], // Node that sent the message
                                direction: 'transmitted'
                            });
                        }

                        // Parse message reception
                        const receiveMatch = line.match(/\*\*\* RECEIVED MESSAGE: type 0x([0-9A-Fa-f]+) from 0x([0-9A-Fa-f]+) to 0x([0-9A-Fa-f]+)/);
                        if (receiveMatch) {
                            const messageTypeInfo = getMessageTypeInfo('0x' + receiveMatch[1], 'received');
                            
                            // Add reception indicator on receiver node (use nodeId from timestamp line)
                            this.messages.push({
                                timestamp,
                                from: receiveMatch[2],
                                to: receiveMatch[3],
                                type: messageTypeInfo.cssClass,
                                typeName: messageTypeInfo.name,
                                category: messageTypeInfo.category,
                                nodeId: nodeId, // Use the node ID from the log line
                                direction: 'received'
                            });
                        }

                        // Parse additional message reception patterns
                        const receivedMatch = line.match(/received message from 0x([0-9A-Fa-f]+) to 0x([0-9A-Fa-f]+)/);
                        if (receivedMatch) {
                            // Try to infer message type from context
                            let messageTypeInfo = { name: 'UNKNOWN', category: 'unknown', cssClass: 'rx' };
                            
                            if (line.includes('sync beacon')) {
                                messageTypeInfo = getMessageTypeInfo(MessageType.SYNC_BEACON, 'received');
                            } else if (line.includes('Join request')) {
                                messageTypeInfo = getMessageTypeInfo(MessageType.JOIN_REQUEST, 'received');
                            } else if (line.includes('routing table')) {
                                messageTypeInfo = getMessageTypeInfo(MessageType.ROUTE_TABLE, 'received');
                            } else if (line.includes('control')) {
                                messageTypeInfo = { name: 'CONTROL', category: 'control', cssClass: 'control-rx' };
                            }
                            
                            // Add reception indicator on receiver node
                            this.messages.push({
                                timestamp,
                                from: receivedMatch[1],
                                to: receivedMatch[2],
                                type: messageTypeInfo.cssClass,
                                typeName: messageTypeInfo.name,
                                category: messageTypeInfo.category,
                                nodeId: receivedMatch[2], // Node that received the message
                                direction: 'received'
                            });
                        }

                        // Parse protocol states
                        const stateMatch = line.match(/Protocol task started|Network service configured|Starting LoRaMesh protocol/);
                        if (stateMatch) {
                            this.events.push({
                                timestamp,
                                nodeId,
                                type: 'protocol_event',
                                event: line.match(/\] (.+)$/)[1]
                            });
                        }

                        // Track nodes
                        if (nodeId !== 'unknown') {
                            if (!this.nodes.has(nodeId)) {
                                this.nodes.set(nodeId, {
                                    id: nodeId,
                                    firstSeen: timestamp,
                                    lastSeen: timestamp,
                                    slots: [],
                                    states: []
                                });
                            }
                            this.nodes.get(nodeId).lastSeen = timestamp;
                        }
                    }
                }

                // Calculate time range
                const allTimestamps = this.events.map(e => e.timestamp);
                this.timeRange.start = Math.min(...allTimestamps);
                this.timeRange.end = Math.max(...allTimestamps);

                console.log('Parsed log:', {
                    events: this.events,
                    messages: this.messages,
                    nodes: this.nodes,
                    timeRange: this.timeRange
                });
            }

            showVisualization() {
                document.getElementById('visualizationContainer').style.display = 'block';
                this.updateLogInfo();
                this.renderTimeline();
                this.renderMessages();
                this.renderStats();
            }

            updateLogInfo() {
                const info = document.getElementById('logInfo');
                info.innerHTML = `
                    <strong>Log Analysis Results:</strong>
                    ${this.nodes.size} nodes detected, 
                    ${this.events.length} events parsed, 
                    ${this.messages.length} messages tracked,
                    Time range: ${this.timeRange.start}ms - ${this.timeRange.end}ms
                `;
            }

            renderTimeline() {
                const timelineContent = document.getElementById('timelineContent');
                timelineContent.innerHTML = '';

                // Initialize time window if not set
                if (this.timeWindowEnd === 0) {
                    this.timeWindowStart = this.timeRange.start;
                    this.timeWindowEnd = this.timeRange.end;
                }

                const windowDuration = this.timeWindowEnd - this.timeWindowStart;
                const totalDuration = this.timeRange.end - this.timeRange.start;
                
                // Calculate pixels per millisecond based on zoom level
                const basePixelsPerMs = 1200 / totalDuration;
                const pixelsPerMs = basePixelsPerMs * this.zoomLevel;
                
                // Set content width based on zoom
                const contentWidth = totalDuration * pixelsPerMs + 200;
                timelineContent.style.width = `${contentWidth}px`;

                this.nodes.forEach((node, nodeId) => {
                    const nodeDiv = document.createElement('div');
                    nodeDiv.className = 'node-timeline';
                    
                    const label = document.createElement('div');
                    label.className = 'node-label';
                    label.textContent = `Node 0x${nodeId}`;
                    nodeDiv.appendChild(label);

                    // Get slot events for this node
                    const nodeSlots = this.events.filter(e => 
                        e.nodeId === nodeId && e.type === 'slot_transition'
                    );

                    // Render individual slot transitions (don't group them)
                    nodeSlots.forEach((slot, index) => {
                        const nextSlot = nodeSlots[index + 1];
                        const slotEnd = nextSlot ? nextSlot.timestamp : slot.timestamp + 100; // Default 100ms if no next slot
                        
                        this.addSlotBar(nodeDiv, {
                            slotType: slot.slotType,
                            start: slot.timestamp,
                            end: slotEnd,
                            slotNum: slot.slotNum
                        }, pixelsPerMs);
                    });

                    // Render message indicators for this node
                    const nodeMessages = this.messages.filter(m => m.nodeId === nodeId);
                    nodeMessages.forEach(message => {
                        this.addMessageIndicator(nodeDiv, message, pixelsPerMs);
                    });

                    timelineContent.appendChild(nodeDiv);
                });

                // Update control labels
                this.updateControlLabels();
            }

            addSlotBar(nodeDiv, slot, pixelsPerMs) {
                const bar = document.createElement('div');
                bar.className = `slot-bar slot-${slot.slotType.toLowerCase()}`;
                
                const left = (slot.start - this.timeRange.start) * pixelsPerMs + 110;
                const width = Math.max(2, (slot.end - slot.start) * pixelsPerMs);
                
                bar.style.left = `${left}px`;
                bar.style.width = `${width}px`;
                
                // Only show text if width is sufficient
                if (width > 40) {
                    bar.textContent = `${slot.slotType} #${slot.slotNum}`;
                } else if (width > 20) {
                    bar.textContent = `#${slot.slotNum}`;
                }
                
                // Enhanced tooltip with detailed information
                const duration = slot.end - slot.start;
                const relativeTime = (slot.start - this.timeRange.start).toFixed(1);
                
                bar.title = `üî∏ Slot ${slot.slotNum}: ${slot.slotType}
üìÖ Start: ${slot.start}ms
‚è±Ô∏è End: ${slot.end}ms  
‚è≥ Duration: ${duration}ms
üìä Relative: ${relativeTime}ms from start`;
                
                nodeDiv.appendChild(bar);
            }

            addMessageIndicator(nodeDiv, message, pixelsPerMs) {
                const indicator = document.createElement('div');
                indicator.className = `message-indicator message-${message.type}`;
                
                const left = (message.timestamp - this.timeRange.start) * pixelsPerMs + 110;
                const width = 3; // Fixed width for message indicators
                
                indicator.style.left = `${left}px`;
                indicator.style.width = `${width}px`;
                
                // Add message type indicator based on the actual message type name
                const typeMap = {
                    'tx': 'TX',
                    'rx': 'RX',
                    'beacon': 'B',
                    'control': 'C',
                    'join': 'J',
                    'routing': 'R',
                    'system': 'S',
                    'unknown': '?'
                };
                
                // Use the typeName if available, otherwise fall back to type
                let displayText = '?';
                if (message.typeName) {
                    // Create shorter display text from typeName
                    switch (message.typeName) {
                        case 'SYNC_BEACON': displayText = 'B'; break;
                        case 'JOIN_REQUEST': 
                        case 'JOIN_RESPONSE': displayText = 'J'; break;
                        case 'ROUTE_TABLE': displayText = 'R'; break;
                        case 'DATA': displayText = 'D'; break;
                        case 'ACK': displayText = 'A'; break;
                        case 'PING': displayText = 'P'; break;
                        case 'PONG': displayText = 'P'; break;
                        case 'HELLO': displayText = 'H'; break;
                        case 'SYNC': displayText = 'S'; break;
                        case 'SLOT_REQUEST': 
                        case 'SLOT_ALLOCATION': displayText = 'S'; break;
                        default: displayText = typeMap[message.type] || '?';
                    }
                } else {
                    displayText = typeMap[message.type] || '?';
                }
                if (width > 15) {
                    indicator.textContent = displayText;
                }
                
                // Enhanced tooltip with detailed message type information
                const direction = message.direction || 'unknown';
                const directionIcon = direction === 'transmitted' ? 'üì§' : 
                                    direction === 'received' ? 'üì•' : 'üìä';
                
                const typeName = message.typeName || message.type.toUpperCase();
                const category = message.category || 'unknown';
                
                const messageInfo = `üî∏ Message: ${typeName} (${category})
üìÖ Time: ${message.timestamp}ms
üì§ From: 0x${message.from}
üì• To: 0x${message.to}
${directionIcon} Direction: ${direction}
üìÇ Category: ${category}
üìä Relative: ${(message.timestamp - this.timeRange.start).toFixed(1)}ms from start`;
                
                indicator.title = messageInfo;
                
                nodeDiv.appendChild(indicator);
            }

            updateControlLabels() {
                const zoomLevelSpan = document.getElementById('zoomLevel');
                const timeRangeLabel = document.getElementById('timeRangeLabel');
                const timeRangeSlider = document.getElementById('timeRangeSlider');
                
                if (zoomLevelSpan) {
                    zoomLevelSpan.textContent = `${this.zoomLevel}x`;
                }
                
                if (timeRangeLabel) {
                    timeRangeLabel.textContent = `${this.timeWindowStart}ms - ${this.timeWindowEnd}ms`;
                }
                
                if (timeRangeSlider) {
                    const totalDuration = this.timeRange.end - this.timeRange.start;
                    const windowDuration = this.timeWindowEnd - this.timeWindowStart;
                    const maxStart = totalDuration - windowDuration;
                    const currentStart = this.timeWindowStart - this.timeRange.start;
                    
                    timeRangeSlider.max = maxStart;
                    timeRangeSlider.value = currentStart;
                }
            }

            renderMessages() {
                const messageFlow = document.getElementById('messageFlow');
                messageFlow.innerHTML = '';

                this.messages.forEach(msg => {
                    const msgDiv = document.createElement('div');
                    msgDiv.className = 'message-item';
                    
                    const direction = msg.direction || 'unknown';
                    const directionIcon = direction === 'transmitted' ? 'üì§' : 
                                        direction === 'received' ? 'üì•' : 'üìä';
                    
                    const typeName = msg.typeName || msg.type.toUpperCase();
                    const category = msg.category || 'unknown';
                    const categoryIcon = {
                        'data': 'üìä',
                        'control': '‚öôÔ∏è',
                        'routing': 'üó∫Ô∏è',
                        'system': 'üîß',
                        'unknown': '‚ùì'
                    }[category] || '‚ùì';
                    
                    msgDiv.innerHTML = `
                        <div class="message-time">${msg.timestamp}ms</div>
                        <div class="message-content">
                            <span class="message-from">0x${msg.from}</span> 
                            ‚Üí 
                            <span class="message-to">0x${msg.to}</span>
                            <span style="margin-left: 10px; color: #2c3e50; font-weight: bold;">${typeName}</span>
                            <span style="margin-left: 5px; color: #7f8c8d;">${categoryIcon} ${category}</span>
                            <span style="margin-left: 5px; color: #7f8c8d;">${directionIcon} ${direction}</span>
                        </div>
                    `;
                    
                    messageFlow.appendChild(msgDiv);
                });
            }

            renderStats() {
                const statsGrid = document.getElementById('statsGrid');
                statsGrid.innerHTML = '';

                const stats = [
                    { label: 'Total Nodes', value: this.nodes.size },
                    { label: 'Total Events', value: this.events.length },
                    { label: 'Messages Sent', value: this.messages.length },
                    { label: 'Duration (ms)', value: this.timeRange.end - this.timeRange.start }
                ];

                stats.forEach(stat => {
                    const card = document.createElement('div');
                    card.className = 'stat-card';
                    card.innerHTML = `
                        <div class="stat-value">${stat.value}</div>
                        <div class="stat-label">${stat.label}</div>
                    `;
                    statsGrid.appendChild(card);
                });
            }

            showError(message) {
                const error = document.createElement('div');
                error.className = 'error';
                error.textContent = message;
                document.querySelector('.container').insertBefore(error, document.querySelector('.upload-section'));
            }
        }

        function showTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
        }

        // Initialize the analyzer
        const analyzer = new LogAnalyzer();

        // Zoom control functions
        function zoomIn() {
            const zoomSlider = document.getElementById('zoomSlider');
            const newValue = Math.min(100, parseInt(zoomSlider.value) + 5);
            zoomSlider.value = newValue;
            updateZoom();
        }

        function zoomOut() {
            const zoomSlider = document.getElementById('zoomSlider');
            const newValue = Math.max(1, parseInt(zoomSlider.value) - 5);
            zoomSlider.value = newValue;
            updateZoom();
        }

        function updateZoom() {
            const zoomSlider = document.getElementById('zoomSlider');
            analyzer.zoomLevel = parseInt(zoomSlider.value);
            analyzer.renderTimeline();
        }

        function updateTimeRange() {
            const timeRangeSlider = document.getElementById('timeRangeSlider');
            const totalDuration = analyzer.timeRange.end - analyzer.timeRange.start;
            const windowDuration = totalDuration / analyzer.zoomLevel;
            const sliderValue = parseInt(timeRangeSlider.value);
            
            analyzer.timeWindowStart = analyzer.timeRange.start + sliderValue;
            analyzer.timeWindowEnd = analyzer.timeWindowStart + windowDuration;
            
            analyzer.renderTimeline();
        }

        function resetView() {
            const zoomSlider = document.getElementById('zoomSlider');
            const timeRangeSlider = document.getElementById('timeRangeSlider');
            
            zoomSlider.value = 10;
            timeRangeSlider.value = 0;
            
            analyzer.zoomLevel = 10;
            analyzer.timeWindowStart = analyzer.timeRange.start;
            analyzer.timeWindowEnd = analyzer.timeRange.end;
            
            analyzer.renderTimeline();
        }

        function toggleLegend() {
            const content = document.getElementById('legendContent');
            const icon = document.getElementById('toggleIcon');
            
            if (content.classList.contains('show')) {
                content.classList.remove('show');
                icon.classList.remove('rotated');
                icon.textContent = '‚ñº';
            } else {
                content.classList.add('show');
                icon.classList.add('rotated');
                icon.textContent = '‚ñ≤';
            }
        }
    </script>
</body>
</html>