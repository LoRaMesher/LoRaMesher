<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoRaMesh Log Analyzer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .upload-section {
            border: 2px dashed #bdc3c7;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            background: #f8f9fa;
        }
        .upload-section.dragover {
            border-color: #3498db;
            background: #e8f4f8;
        }
        .file-input {
            margin: 20px 0;
        }
        .btn {
            background: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        .btn:hover {
            background: #2980b9;
        }
        .visualization-container {
            display: none;
            margin-top: 20px;
        }
        .tabs {
            display: flex;
            border-bottom: 2px solid #ecf0f1;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            background: #ecf0f1;
            border: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 4px 4px 0 0;
        }
        .tab.active {
            background: #3498db;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .timeline-container {
            width: 100%;
            border: 1px solid #ddd;
        }
        .timeline-controls {
            background: #f8f9fa;
            padding: 10px;
            border-bottom: 1px solid #ddd;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .timeline-controls label {
            font-weight: bold;
            color: #2c3e50;
        }
        .timeline-controls input[type="range"] {
            flex: 1;
            margin: 0 10px;
        }
        .timeline-controls button {
            background: #3498db;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .timeline-controls button:hover {
            background: #2980b9;
        }
        .timeline {
            width: 100%;
            height: 400px;
            overflow-x: auto;
            overflow-y: hidden;
            position: relative;
        }
        .timeline-content {
            position: relative;
            height: 100%;
            min-width: 100%;
        }
        .node-timeline {
            height: 100px;
            border-bottom: 1px solid #eee;
            position: relative;
        }
        .node-label {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-weight: bold;
            color: #2c3e50;
            width: 100px;
            z-index: 10;
            background: white;
            padding: 2px 5px;
        }
        .slot-bar {
            height: 30px;
            position: absolute;
            top: 15px;
            border-radius: 4px;
            color: white;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.85;
            border: 1px solid rgba(0,0,0,0.3);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        .message-indicator {
            height: 20px;
            position: absolute;
            top: 50px;
            border-radius: 10px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
            border: 2px solid rgba(0,0,0,0.4);
            min-width: 20px;
        }
        /* Transmitted messages (darker/saturated colors) */
        .message-tx { 
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }
        .message-beacon { 
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
        }
        .message-join { 
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }
        .message-control { 
            background: linear-gradient(135deg, #34495e, #2c3e50);
            color: white;
        }
        .message-routing { 
            background: linear-gradient(135deg, #e67e22, #d35400);
            color: white;
        }
        .message-system { 
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            color: white;
        }
        .message-unknown { 
            background: linear-gradient(135deg, #bdc3c7, #95a5a6);
            color: white;
        }

        /* Received messages (lighter/pastel colors) */
        .message-rx { 
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }
        .message-beacon-rx { 
            background: linear-gradient(135deg, #c39bd3, #bb8fce);
            color: white;
        }
        .message-join-rx { 
            background: linear-gradient(135deg, #7fb3d3, #6c9bd1);
            color: white;
        }
        .message-control-rx { 
            background: linear-gradient(135deg, #85929e, #7d8693);
            color: white;
        }
        .message-routing-rx { 
            background: linear-gradient(135deg, #f0b27a, #eb984e);
            color: white;
        }
        .message-system-rx { 
            background: linear-gradient(135deg, #b2babb, #a6acaf);
            color: white;
        }
        .message-unknown-rx { 
            background: linear-gradient(135deg, #d5dbdb, #cacfd2);
            color: white;
        }
        .message-indicator:hover {
            opacity: 1;
            transform: scaleY(1.2);
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            border-width: 2px;
        }
        .slot-bar:hover {
            opacity: 1;
            transform: scaleY(1.15);
            z-index: 100;
            box-shadow: 0 3px 12px rgba(0,0,0,0.4);
            border-width: 2px;
        }
        .slot-sleep { background: #95a5a6; }
        .slot-tx { background: #e74c3c; }
        .slot-rx { background: #27ae60; }
        .slot-sync_beacon_tx { background: #f39c12; }
        .slot-sync_beacon_rx { background: #f39c12; }
        .slot-discovery { background: #9b59b6; }
        .slot-discovery_rx { background: #9b59b6; }
        .slot-discovery_tx { background: #8e44ad; }
        .slot-control_tx { background: #e67e22; }
        .slot-control_rx { background: #d35400; }
        .slot-joining { background: #16a085; }
        .slot-data { background: #2980b9; }
        .network-graph {
            width: 100%;
            height: 500px;
            border: 1px solid #ddd;
        }
        .message-flow {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            overflow-y: auto;
        }
        .message-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
        }
        .message-time {
            font-family: monospace;
            color: #7f8c8d;
            margin-right: 15px;
            min-width: 100px;
        }
        .message-content {
            flex: 1;
        }
        .message-from {
            font-weight: bold;
            color: #e74c3c;
        }
        .message-to {
            font-weight: bold;
            color: #27ae60;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }
        .stat-label {
            color: #7f8c8d;
            margin-top: 5px;
        }
        .log-info {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .error {
            color: #e74c3c;
            background: #fdf2f2;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .legend-container {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        .legend-header {
            background: #e9ecef;
            padding: 12px 15px;
            cursor: pointer;
            font-weight: bold;
            color: #495057;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .legend-header:hover {
            background: #dee2e6;
        }
        .legend-content {
            padding: 15px;
            display: none;
        }
        .legend-content.show {
            display: block;
        }
        .legend-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .legend-section {
            background: white;
            border-radius: 6px;
            padding: 15px;
            border: 1px solid #e9ecef;
        }
        .legend-section h4 {
            margin: 0 0 12px 0;
            color: #495057;
            font-size: 14px;
            font-weight: bold;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .legend-color {
            width: 20px;
            height: 16px;
            border-radius: 3px;
            margin-right: 10px;
            border: 1px solid rgba(0,0,0,0.2);
        }
        .legend-text {
            font-size: 13px;
            color: #495057;
        }
        .toggle-icon {
            font-size: 12px;
            transition: transform 0.3s ease;
        }
        .toggle-icon.rotated {
            transform: rotate(180deg);
        }
        .file-management {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        .file-list {
            margin: 15px 0;
        }
        .file-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            margin-bottom: 5px;
            background: #f8f9fa;
        }
        .file-item.disabled {
            opacity: 0.5;
            background: #e9ecef;
        }
        .file-checkbox {
            margin-right: 10px;
        }
        .file-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .file-name {
            font-weight: bold;
            color: #2c3e50;
        }
        .file-size {
            color: #7f8c8d;
            font-size: 12px;
        }
        .file-stats {
            color: #7f8c8d;
            font-size: 12px;
        }
        .file-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid rgba(0,0,0,0.2);
        }
        .file-remove {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .file-remove:hover {
            background: #c0392b;
        }
        .file-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .timestamp-controls {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }
        .timestamp-controls h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }
        .timestamp-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .timestamp-toggle input[type="radio"] {
            margin-right: 5px;
        }
        .refresh-drop-zone {
            display: none;
            background: #fff3cd;
            border: 2px dashed #ffc107;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            margin: 15px 0;
        }
        .refresh-drop-zone.show {
            display: block;
        }
        .refresh-drop-zone.dragover {
            background: #ffe8a1;
            border-color: #ff9800;
        }
        .refresh-drop-zone h4 {
            margin: 0 0 10px 0;
            color: #856404;
        }
        .refresh-drop-zone p {
            margin: 5px 0;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>LoRaMesh Log Analyzer</h1>
        
        <div class="upload-section" id="uploadSection">
            <h3>Upload Log Files</h3>
            <p id="uploadHint">Drag and drop log files here or click to select multiple files</p>
            <input type="file" id="fileInput" accept=".txt,.log,.ans" multiple style="display: none;">
            <button class="btn" onclick="selectFiles()">Select Files</button>
        </div>

        <div class="file-management" id="fileManagement" style="display: none;">
            <h3>Loaded Files</h3>
            <div class="file-list" id="fileList"></div>
            <div class="file-controls">
                <button class="btn" onclick="refreshFiles()">üîÑ Refresh</button>
                <button class="btn" onclick="clearAllFiles()">Clear All</button>
                <button class="btn" onclick="toggleAllFiles()">Toggle All</button>
            </div>
        </div>

        <div class="visualization-container" id="visualizationContainer">
            <div class="timestamp-controls" id="timestampControls">
                <h4>‚è∞ Timestamp Format</h4>
                <div class="timestamp-toggle">
                    <label><input type="radio" name="timestampFormat" value="readable" checked onchange="toggleTimestampFormat()"> Readable (HH:MM:SS.mmm)</label>
                    <label><input type="radio" name="timestampFormat" value="milliseconds" onchange="toggleTimestampFormat()"> Raw Milliseconds</label>
                </div>
            </div>
            <div class="log-info" id="logInfo"></div>

            <div class="refresh-drop-zone" id="refreshDropZone">
                <h4>üîÑ File Access Needed</h4>
                <p>The browser needs fresh permission to read your files.</p>
                <p><strong>Drag and drop your log files here to refresh the data.</strong></p>
                <p><small>Tip: Click here to select files, or drag them from your file explorer</small></p>
            </div>

            <div class="legend-container">
                <div class="legend-header" onclick="toggleLegend()">
                    <span>üìä Message Type Color Legend</span>
                    <span class="toggle-icon" id="toggleIcon">‚ñº</span>
                </div>
                <div class="legend-content" id="legendContent">
                    <div class="legend-grid">
                        <div class="legend-section">
                            <h4>üì§ Transmitted Messages (Darker Colors)</h4>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #9b59b6, #8e44ad);"></div>
                                <span class="legend-text">SYNC_BEACON</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #3498db, #2980b9);"></div>
                                <span class="legend-text">JOIN_REQUEST/RESPONSE</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #e67e22, #d35400);"></div>
                                <span class="legend-text">ROUTE_TABLE</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #34495e, #2c3e50);"></div>
                                <span class="legend-text">CONTROL</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #e74c3c, #c0392b);"></div>
                                <span class="legend-text">DATA</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #95a5a6, #7f8c8d);"></div>
                                <span class="legend-text">SYSTEM</span>
                            </div>
                        </div>
                        <div class="legend-section">
                            <h4>üì• Received Messages (Lighter Colors)</h4>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #c39bd3, #bb8fce);"></div>
                                <span class="legend-text">SYNC_BEACON</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #7fb3d3, #6c9bd1);"></div>
                                <span class="legend-text">JOIN_REQUEST/RESPONSE</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #f0b27a, #eb984e);"></div>
                                <span class="legend-text">ROUTE_TABLE</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #85929e, #7d8693);"></div>
                                <span class="legend-text">CONTROL</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #27ae60, #229954);"></div>
                                <span class="legend-text">DATA</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #b2babb, #a6acaf);"></div>
                                <span class="legend-text">SYSTEM</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="tabs">
                <button class="tab active" onclick="showTab('timeline')">Timeline</button>
                <button class="tab" onclick="showTab('network')">Network</button>
                <button class="tab" onclick="showTab('messages')">Messages</button>
                <button class="tab" onclick="showTab('stats')">Statistics</button>
            </div>

            <div id="timeline" class="tab-content active">
                <h3>Slot Timeline</h3>
                <div class="timeline-container">
                    <div class="timeline-controls">
                        <label>Zoom:</label>
                        <button onclick="zoomOut()">-</button>
                        <input type="range" id="zoomSlider" min="1" max="100" value="10" oninput="updateZoom()">
                        <button onclick="zoomIn()">+</button>
                        <span id="zoomLevel">10x</span>

                        <label style="margin-left: 20px;">Time Range:</label>
                        <input type="range" id="timeRangeSlider" min="0" max="100" value="0" oninput="updateTimeRange()">
                        <span id="timeRangeLabel">0ms - 1000ms</span>

                        <button onclick="resetView()" style="margin-left: 20px;">Reset View</button>
                        <button onclick="refreshFiles()" style="margin-left: 10px;">üîÑ Refresh</button>
                    </div>
                    <div class="timeline" id="slotTimeline">
                        <div class="timeline-content" id="timelineContent"></div>
                    </div>
                </div>
            </div>

            <div id="network" class="tab-content">
                <h3>Network Topology</h3>
                <div class="network-graph" id="networkGraph"></div>
            </div>

            <div id="messages" class="tab-content">
                <h3>Message Flow</h3>
                <div class="message-flow" id="messageFlow"></div>
            </div>

            <div id="stats" class="tab-content">
                <h3>Network Statistics</h3>
                <div class="stats-grid" id="statsGrid"></div>
            </div>
        </div>
    </div>

    <script>
        // MessageType mapping from message_type.hpp
        const MessageType = {
            ANY: 0x00,
            
            // Main categories (high nibble)
            DATA_MSG: 0x10,
            CONTROL_MSG: 0x20,
            ROUTING_MSG: 0x30,
            SYSTEM_MSG: 0x40,
            
            // Specific message types
            DATA: 0x11,
            
            ACK: 0x21,
            PING: 0x23,
            PONG: 0x24,
            
            HELLO: 0x31,
            ROUTE_TABLE: 0x32,
            
            SYNC: 0x41,
            JOIN_REQUEST: 0x42,
            JOIN_RESPONSE: 0x43,
            SLOT_REQUEST: 0x44,
            SLOT_ALLOCATION: 0x45,
            SYNC_BEACON: 0x46
        };

        // Message type name mapping
        const MessageTypeName = {
            [MessageType.ANY]: 'ANY',
            [MessageType.DATA]: 'DATA',
            [MessageType.ACK]: 'ACK',
            [MessageType.PING]: 'PING',
            [MessageType.PONG]: 'PONG',
            [MessageType.HELLO]: 'HELLO',
            [MessageType.ROUTE_TABLE]: 'ROUTE_TABLE',
            [MessageType.SYNC]: 'SYNC',
            [MessageType.JOIN_REQUEST]: 'JOIN_REQUEST',
            [MessageType.JOIN_RESPONSE]: 'JOIN_RESPONSE',
            [MessageType.SLOT_REQUEST]: 'SLOT_REQUEST',
            [MessageType.SLOT_ALLOCATION]: 'SLOT_ALLOCATION',
            [MessageType.SYNC_BEACON]: 'SYNC_BEACON'
        };

        // Helper functions for message type categorization
        function getMainType(type) {
            return type & 0xF0;
        }

        function getMessageTypeInfo(typeValue, direction = 'transmitted') {
            // Convert string to number if needed
            const numType = typeof typeValue === 'string' ? 
                (typeValue.startsWith('0x') ? parseInt(typeValue, 16) : parseInt(typeValue, 10)) : 
                typeValue;
            
            const typeName = MessageTypeName[numType];
            if (!typeName) {
                return { name: 'UNKNOWN', category: 'unknown', cssClass: direction === 'received' ? 'unknown-rx' : 'unknown' };
            }
            
            const mainType = getMainType(numType);
            let category, cssClass;
            
            switch (mainType) {
                case MessageType.DATA_MSG:
                    category = 'data';
                    cssClass = direction === 'received' ? 'tx' : 'tx'; // Keep tx for both for now
                    break;
                case MessageType.CONTROL_MSG:
                    category = 'control';
                    cssClass = direction === 'received' ? 'control-rx' : 'control';
                    break;
                case MessageType.ROUTING_MSG:
                    category = 'routing';
                    cssClass = direction === 'received' ? 'routing-rx' : 'routing';
                    break;
                case MessageType.SYSTEM_MSG:
                    category = 'system';
                    if (numType === MessageType.SYNC_BEACON) {
                        cssClass = direction === 'received' ? 'beacon-rx' : 'beacon';
                    } else if (numType === MessageType.JOIN_REQUEST || numType === MessageType.JOIN_RESPONSE) {
                        cssClass = direction === 'received' ? 'join-rx' : 'join';
                    } else {
                        cssClass = direction === 'received' ? 'system-rx' : 'system';
                    }
                    break;
                default:
                    category = 'unknown';
                    cssClass = direction === 'received' ? 'unknown-rx' : 'unknown';
            }
            
            return { name: typeName, category, cssClass };
        }

        class LogAnalyzer {
            constructor() {
                this.files = new Map(); // Map of file ID to file data
                this.nodes = new Map();
                this.messages = [];
                this.events = [];
                this.timeRange = { start: 0, end: 0 };
                this.zoomLevel = 10;
                this.timeWindowStart = 0;
                this.timeWindowEnd = 0;
                this.pendingTransmission = null;
                this.timestampFormat = 'readable'; // 'readable' or 'milliseconds'
                this.baseTimestamp = 0; // First timestamp for relative calculations
                this.originalTimeMap = new Map(); // Maps timestamp to original time format
                this.fileColors = ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#34495e', '#e67e22'];
                this.isRefreshMode = false; // Track if we're in refresh mode

                // Check for File System Access API support
                this.supportsFileSystemAccess = 'showOpenFilePicker' in window;
                console.log(`üîç File System Access API supported: ${this.supportsFileSystemAccess}`);
                if (this.supportsFileSystemAccess) {
                    console.log('‚ú® True file refresh available! Use "Select Files" button for best experience.');
                    // Update UI hint
                    const uploadHint = document.getElementById('uploadHint');
                    if (uploadHint) {
                        uploadHint.innerHTML = `Drag and drop log files here or <strong>click "Select Files" for auto-refresh support</strong>`;
                    }
                } else {
                    console.log('‚ÑπÔ∏è Using fallback mode. Refresh will require re-selecting files.');
                }

                this.setupEventListeners();
            }

            setupEventListeners() {
                const uploadSection = document.getElementById('uploadSection');
                const fileInput = document.getElementById('fileInput');
                const refreshDropZone = document.getElementById('refreshDropZone');

                uploadSection.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadSection.classList.add('dragover');
                });

                uploadSection.addEventListener('dragleave', () => {
                    uploadSection.classList.remove('dragover');
                });

                uploadSection.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadSection.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.processFiles(Array.from(files));
                    }
                });

                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        if (this.isRefreshMode) {
                            this.processFilesForRefresh(Array.from(e.target.files));
                            this.isRefreshMode = false; // Reset flag
                        } else {
                            this.processFiles(Array.from(e.target.files));
                        }
                        // Clear the input so the same file can be selected again
                        e.target.value = '';
                    }
                });

                // Refresh drop zone event listeners
                refreshDropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    refreshDropZone.classList.add('dragover');
                });

                refreshDropZone.addEventListener('dragleave', () => {
                    refreshDropZone.classList.remove('dragover');
                });

                refreshDropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    refreshDropZone.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.processFilesForRefresh(Array.from(files));
                    }
                });

                refreshDropZone.addEventListener('click', () => {
                    this.isRefreshMode = true; // Set refresh mode flag
                    fileInput.click();
                });
            }

            formatTimestamp(timestamp) {
                if (this.timestampFormat === 'milliseconds') {
                    return `${timestamp}ms`;
                }

                // Check if we have original time format stored
                if (this.originalTimeMap.has(timestamp)) {
                    return this.originalTimeMap.get(timestamp);
                }

                // For files with original time format, try to find closest timestamp
                if (this.originalTimeMap.size > 0) {
                    // Find the closest timestamp that has original time format
                    let closestTimestamp = null;
                    let closestDiff = Infinity;

                    for (let [storedTimestamp] of this.originalTimeMap) {
                        const diff = Math.abs(timestamp - storedTimestamp);
                        if (diff < closestDiff) {
                            closestDiff = diff;
                            closestTimestamp = storedTimestamp;
                        }
                    }

                    if (closestTimestamp !== null && closestDiff < 1000) { // Within 1 second
                        const originalTime = this.originalTimeMap.get(closestTimestamp);
                        const timeDiff = timestamp - closestTimestamp;

                        // Parse original time
                        const [timePart, msPart] = originalTime.split('.');
                        const [hours, minutes, seconds] = timePart.split(':').map(Number);

                        // Calculate new time with offset
                        const totalMs = (hours * 3600 + minutes * 60 + seconds) * 1000 + parseInt(msPart) + timeDiff;
                        const newHours = Math.floor(totalMs / (1000 * 60 * 60)) % 24;
                        const newMinutes = Math.floor((totalMs % (1000 * 60 * 60)) / (1000 * 60));
                        const newSeconds = Math.floor((totalMs % (1000 * 60)) / 1000);
                        const newMs = totalMs % 1000;

                        return `${newHours.toString().padStart(2, '0')}:${newMinutes.toString().padStart(2, '0')}:${newSeconds.toString().padStart(2, '0')}.${Math.floor(newMs).toString().padStart(3, '0')}`;
                    }
                }

                // Fallback to relative time format for millisecond-based logs
                const relativeMs = timestamp - this.baseTimestamp;
                const hours = Math.floor(relativeMs / (1000 * 60 * 60));
                const minutes = Math.floor((relativeMs % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((relativeMs % (1000 * 60)) / 1000);
                const milliseconds = relativeMs % 1000;

                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${Math.floor(milliseconds).toString().padStart(3, '0')}`;
            }

            async selectFilesWithPicker() {
                try {
                    const fileHandles = await window.showOpenFilePicker({
                        multiple: true,
                        types: [{
                            description: 'Log Files',
                            accept: {
                                'text/plain': ['.txt', '.log', '.ans']
                            }
                        }]
                    });

                    console.log(`üìÇ Selected ${fileHandles.length} file(s) with File System Access API`);

                    for (const fileHandle of fileHandles) {
                        const file = await fileHandle.getFile();
                        await this.processFileWithHandle(file, fileHandle);
                    }
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.error('Error selecting files:', error);
                    }
                    // User cancelled or error occurred
                }
            }

            processFiles(files) {
                files.forEach(file => {
                    this.processFile(file);
                });
            }

            async processFileWithHandle(file, fileHandle) {
                const fileId = `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const colorIndex = this.files.size % this.fileColors.length;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const fileData = {
                            id: fileId,
                            name: file.name,
                            size: file.size,
                            content: e.target.result,
                            color: this.fileColors[colorIndex],
                            enabled: true,
                            nodes: new Map(),
                            messages: [],
                            events: [],
                            timeRange: { start: 0, end: 0 },
                            file: file,  // Store File object
                            fileHandle: fileHandle  // Store FileSystemFileHandle for true refresh!
                        };

                        console.log(`‚úÖ Loaded ${file.name} with file handle (true refresh enabled)`);

                        this.parseLogFile(fileData);
                        this.files.set(fileId, fileData);
                        this.updateFileList();
                        this.aggregateData();
                        this.showVisualization();
                    } catch (error) {
                        this.showError('Error parsing log file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }

            processFilesForRefresh(files) {
                console.log(`üîÑ Processing ${files.length} file(s) for refresh...`);

                // Hide the refresh drop zone
                const refreshDropZone = document.getElementById('refreshDropZone');
                refreshDropZone.classList.remove('show');

                // Show loading indicator
                const logInfo = document.getElementById('logInfo');
                logInfo.innerHTML = '<strong>üîÑ Updating files...</strong>';
                logInfo.style.background = '#fff3cd';

                let filesProcessed = 0;
                const updateResults = {
                    updated: [],
                    added: [],
                    failed: []
                };

                files.forEach(file => {
                    // Try to find existing file by name
                    let existingFileData = null;
                    for (const [fileId, fileData] of this.files.entries()) {
                        if (fileData.name === file.name) {
                            existingFileData = { id: fileId, data: fileData };
                            break;
                        }
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            if (existingFileData) {
                                // Update existing file
                                console.log(`‚úÖ Updating existing file: ${file.name}`);
                                existingFileData.data.content = e.target.result;
                                existingFileData.data.size = file.size;
                                existingFileData.data.file = file; // Update file reference
                                this.parseLogFile(existingFileData.data);
                                updateResults.updated.push(file.name);
                            } else {
                                // Add as new file
                                console.log(`‚ûï Adding new file: ${file.name}`);
                                const fileId = `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                                const colorIndex = this.files.size % this.fileColors.length;

                                const fileData = {
                                    id: fileId,
                                    name: file.name,
                                    size: file.size,
                                    content: e.target.result,
                                    color: this.fileColors[colorIndex],
                                    enabled: true,
                                    nodes: new Map(),
                                    messages: [],
                                    events: [],
                                    timeRange: { start: 0, end: 0 },
                                    file: file
                                };

                                this.parseLogFile(fileData);
                                this.files.set(fileId, fileData);
                                updateResults.added.push(file.name);
                            }

                            filesProcessed++;
                            if (filesProcessed === files.length) {
                                this.finishFileUpdate(logInfo, updateResults);
                            }
                        } catch (error) {
                            console.error(`‚ùå Error processing ${file.name}:`, error);
                            updateResults.failed.push({ name: file.name, error: error.message });
                            filesProcessed++;
                            if (filesProcessed === files.length) {
                                this.finishFileUpdate(logInfo, updateResults);
                            }
                        }
                    };

                    reader.onerror = () => {
                        const errorDetails = reader.error ? reader.error.message : 'Unknown error';
                        console.error(`‚ùå Error reading ${file.name}:`, errorDetails);
                        updateResults.failed.push({ name: file.name, error: errorDetails });
                        filesProcessed++;
                        if (filesProcessed === files.length) {
                            this.finishFileUpdate(logInfo, updateResults);
                        }
                    };

                    reader.readAsText(file);
                });
            }

            finishFileUpdate(logInfo, results) {
                // Re-aggregate and re-render
                this.aggregateData();
                this.updateFileList();
                this.updateLogInfo();
                this.renderTimeline();
                this.renderMessages();
                this.renderStats();

                // Show success message
                logInfo.style.background = '#d4edda';
                let message = '<strong>‚úÖ Files updated successfully!</strong><br>';
                if (results.updated.length > 0) {
                    message += `<small>Updated: ${results.updated.join(', ')}</small>`;
                }
                if (results.added.length > 0) {
                    message += `<small>Added: ${results.added.join(', ')}</small>`;
                }
                if (results.failed.length > 0) {
                    message += `<small>Failed: ${results.failed.map(f => f.name).join(', ')}</small>`;
                }

                logInfo.innerHTML = message;

                setTimeout(() => {
                    logInfo.style.background = '#e8f4f8';
                    this.updateLogInfo();
                }, 3000);

                console.log('üìä File Update Summary:', results);
            }

            processFile(file) {
                const fileId = `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const colorIndex = this.files.size % this.fileColors.length;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const fileData = {
                            id: fileId,
                            name: file.name,
                            size: file.size,
                            content: e.target.result,
                            color: this.fileColors[colorIndex],
                            enabled: true,
                            nodes: new Map(),
                            messages: [],
                            events: [],
                            timeRange: { start: 0, end: 0 },
                            file: file  // Store original File object for refreshing
                        };

                        this.parseLogFile(fileData);
                        this.files.set(fileId, fileData);
                        this.updateFileList();
                        this.aggregateData();
                        this.showVisualization();
                    } catch (error) {
                        this.showError('Error parsing log file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }

            parseLogFile(fileData) {
                const logContent = fileData.content;
                fileData.events = [];
                fileData.messages = [];
                fileData.nodes.clear();
                fileData.originalTimeMap = new Map();
                let pendingTransmission = null;

                const lines = logContent.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim().replace(/\x1b\[[0-9;]*m/g, '');
                    if (!line) continue;

                    // Parse both timestamp formats
                    let timestamp, nodeId;

                    // Format 1: [520420022 ms] [INFO] [0x1001] message
                    const msTimestampMatch = line.match(/\[(\d+) ms\]/);
                    // Format 2: 11:10:33.936 > [INFO] [0x8681] message
                    const timeTimestampMatch = line.match(/^(\d{1,2}):(\d{2}):(\d{2})\.(\d{3})\s*>/);

                    if (msTimestampMatch) {
                        timestamp = parseInt(msTimestampMatch[1]);
                        const nodeMatch = line.match(/\[0x([0-9A-Fa-f]+)\]/);
                        nodeId = nodeMatch ? nodeMatch[1] : 'unknown';
                    } else if (timeTimestampMatch) {
                        // Store original time format and convert to milliseconds
                        const hours = parseInt(timeTimestampMatch[1]);
                        const minutes = parseInt(timeTimestampMatch[2]);
                        const seconds = parseInt(timeTimestampMatch[3]);
                        const ms = parseInt(timeTimestampMatch[4]);
                        timestamp = (hours * 3600 + minutes * 60 + seconds) * 1000 + ms;

                        // Store original time format for display
                        const originalTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
                        fileData.originalTimeMap.set(timestamp, originalTime);

                        const nodeMatch = line.match(/\[0x([0-9A-Fa-f]+)\]/);
                        nodeId = nodeMatch ? nodeMatch[1] : 'unknown';
                    } else {
                        continue; // Skip lines without timestamp
                    }

                    // Use existing parsing logic
                    pendingTransmission = this.parseLineForFile(line, timestamp, nodeId, fileData, pendingTransmission);
                }

                // Calculate time range for this file
                const allTimestamps = fileData.events.map(e => e.timestamp).concat(
                    fileData.messages.map(m => m.timestamp)
                );
                if (allTimestamps.length > 0) {
                    fileData.timeRange.start = Math.min(...allTimestamps);
                    fileData.timeRange.end = Math.max(...allTimestamps);
                }
            }

            parseLineForFile(line, timestamp, nodeId, fileData, pendingTransmission) {
                // Parse slot transitions
                const slotMatch = line.match(/Slot (\d+) transition: type=(\w+)/);
                if (slotMatch) {
                    const slotNum = parseInt(slotMatch[1]);
                    const slotType = slotMatch[2];

                    fileData.events.push({
                        timestamp,
                        nodeId,
                        type: 'slot_transition',
                        slotNum,
                        slotType,
                        fileId: fileData.id
                    });
                }

                // Parse message transmissions - handle "Sending message" pattern first
                const sendingMatch = line.match(/Sending message to 0x([0-9A-Fa-f]+), type: (\d+)/);
                if (sendingMatch) {
                    const messageTypeInfo = getMessageTypeInfo(sendingMatch[2], 'transmitted');

                    // Add message directly for ESP32 logs (which don't have "Transmitting" line)
                    fileData.messages.push({
                        timestamp,
                        from: nodeId,
                        to: sendingMatch[1],
                        type: messageTypeInfo.cssClass,
                        typeName: messageTypeInfo.name,
                        category: messageTypeInfo.category,
                        nodeId: nodeId,
                        direction: 'transmitted',
                        fileId: fileData.id
                    });

                    // Still return pendingTransmission for backward compatibility with desktop logs
                    return {
                        timestamp,
                        nodeId,
                        to: sendingMatch[1],
                        messageTypeInfo
                    };
                }

                // Parse "Transmitting message from X to Y" pattern
                let transmitMatch = line.match(/Transmitting message from 0x([0-9A-Fa-f]+) to 0x([0-9A-Fa-f]+)/);
                if (!transmitMatch) {
                    transmitMatch = line.match(/Transmitting message from 0x([0-9A-Fa-f]+)/);
                    if (transmitMatch) {
                        transmitMatch[2] = 'FFFF';
                    }
                }

                if (transmitMatch) {
                    let messageTypeInfo = { name: 'UNKNOWN', category: 'unknown', cssClass: 'tx' };

                    if (pendingTransmission &&
                        pendingTransmission.nodeId === nodeId &&
                        Math.abs(pendingTransmission.timestamp - timestamp) < 100) {
                        messageTypeInfo = pendingTransmission.messageTypeInfo;
                        pendingTransmission = null;
                    }

                    fileData.messages.push({
                        timestamp,
                        from: transmitMatch[1],
                        to: transmitMatch[2],
                        type: messageTypeInfo.cssClass,
                        typeName: messageTypeInfo.name,
                        category: messageTypeInfo.category,
                        nodeId: transmitMatch[1],
                        direction: 'transmitted',
                        fileId: fileData.id
                    });
                }

                // Parse message reception - "*** RECEIVED MESSAGE:" pattern
                const receiveMatch = line.match(/\*\*\* RECEIVED MESSAGE: type 0x([0-9A-Fa-f]+) from 0x([0-9A-Fa-f]+) to 0x([0-9A-Fa-f]+)/);
                if (receiveMatch) {
                    const messageTypeInfo = getMessageTypeInfo('0x' + receiveMatch[1], 'received');

                    fileData.messages.push({
                        timestamp,
                        from: receiveMatch[2],
                        to: receiveMatch[3],
                        type: messageTypeInfo.cssClass,
                        typeName: messageTypeInfo.name,
                        category: messageTypeInfo.category,
                        nodeId: nodeId,
                        direction: 'received',
                        fileId: fileData.id
                    });
                }

                // Parse message reception - "*** PROCESSING [TYPE] from 0xXXXX" pattern (ESP32 logs)
                const processingMatch = line.match(/\*\*\* PROCESSING ([A-Z_]+) from 0x([0-9A-Fa-f]+)/);
                if (processingMatch) {
                    // Map message type name to numeric value
                    const messageTypeName = processingMatch[1];
                    const messageTypeMap = {
                        'JOIN_REQUEST': MessageType.JOIN_REQUEST,
                        'JOIN_RESPONSE': MessageType.JOIN_RESPONSE,
                        'SLOT_REQUEST': MessageType.SLOT_REQUEST,
                        'SLOT_ALLOCATION': MessageType.SLOT_ALLOCATION,
                        'SYNC_BEACON': MessageType.SYNC_BEACON,
                        'ROUTE_TABLE': MessageType.ROUTE_TABLE
                    };

                    const typeNum = messageTypeMap[messageTypeName];
                    if (typeNum) {
                        const messageTypeInfo = getMessageTypeInfo(typeNum, 'received');

                        fileData.messages.push({
                            timestamp,
                            from: processingMatch[2],
                            to: nodeId,
                            type: messageTypeInfo.cssClass,
                            typeName: messageTypeInfo.name,
                            category: messageTypeInfo.category,
                            nodeId: nodeId,
                            direction: 'received',
                            fileId: fileData.id
                        });
                    }
                }

                // Track nodes
                if (nodeId !== 'unknown') {
                    if (!fileData.nodes.has(nodeId)) {
                        fileData.nodes.set(nodeId, {
                            id: nodeId,
                            firstSeen: timestamp,
                            lastSeen: timestamp,
                            slots: [],
                            states: []
                        });
                    }
                    fileData.nodes.get(nodeId).lastSeen = timestamp;
                }

                return pendingTransmission;
            }

            updateFileList() {
                const fileList = document.getElementById('fileList');
                const fileManagement = document.getElementById('fileManagement');

                if (this.files.size === 0) {
                    fileManagement.style.display = 'none';
                    return;
                }

                fileManagement.style.display = 'block';
                fileList.innerHTML = '';

                this.files.forEach((fileData) => {
                    const fileItem = document.createElement('div');
                    fileItem.className = `file-item ${!fileData.enabled ? 'disabled' : ''}`;

                    fileItem.innerHTML = `
                        <input type=\"checkbox\" class=\"file-checkbox\" ${fileData.enabled ? 'checked' : ''} onchange=\"analyzer.toggleFile('${fileData.id}')\">
                        <div class=\"file-color\" style=\"background-color: ${fileData.color}\"></div>
                        <div class=\"file-info\">
                            <div class=\"file-name\">${fileData.name}</div>
                            <div class=\"file-size\">${(fileData.size / 1024).toFixed(1)} KB</div>
                            <div class=\"file-stats\">${fileData.events.length} events, ${fileData.messages.length} messages</div>
                        </div>
                        <button class=\"file-remove\" onclick=\"analyzer.removeFile('${fileData.id}')\">Remove</button>
                    `;

                    fileList.appendChild(fileItem);
                });
            }

            aggregateData() {
                this.nodes.clear();
                this.messages = [];
                this.events = [];
                this.originalTimeMap.clear();

                let allTimestamps = [];

                this.files.forEach((fileData) => {
                    if (!fileData.enabled) return;

                    // Merge nodes
                    fileData.nodes.forEach((node, nodeId) => {
                        if (!this.nodes.has(nodeId)) {
                            this.nodes.set(nodeId, {
                                id: nodeId,
                                firstSeen: node.firstSeen,
                                lastSeen: node.lastSeen,
                                slots: [],
                                states: []
                            });
                        } else {
                            const existingNode = this.nodes.get(nodeId);
                            existingNode.firstSeen = Math.min(existingNode.firstSeen, node.firstSeen);
                            existingNode.lastSeen = Math.max(existingNode.lastSeen, node.lastSeen);
                        }
                    });

                    // Merge messages and events
                    this.messages = this.messages.concat(fileData.messages);
                    this.events = this.events.concat(fileData.events);

                    // Merge originalTimeMap if it exists
                    if (fileData.originalTimeMap) {
                        fileData.originalTimeMap.forEach((originalTime, timestamp) => {
                            this.originalTimeMap.set(timestamp, originalTime);
                        });
                    }

                    allTimestamps = allTimestamps.concat(
                        fileData.events.map(e => e.timestamp),
                        fileData.messages.map(m => m.timestamp)
                    );
                });

                // Calculate global time range
                if (allTimestamps.length > 0) {
                    this.timeRange.start = Math.min(...allTimestamps);
                    this.timeRange.end = Math.max(...allTimestamps);

                    // Set base timestamp for readable format
                    if (this.baseTimestamp === 0) {
                        this.baseTimestamp = this.timeRange.start;
                    }
                }

                // Sort by timestamp
                this.messages.sort((a, b) => a.timestamp - b.timestamp);
                this.events.sort((a, b) => a.timestamp - b.timestamp);
            }

            parseLog(logContent) {
                const lines = logContent.split('\n');
                this.events = [];
                this.messages = [];
                this.nodes.clear();
                this.pendingTransmission = null;

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    // Parse timestamp and node info
                    const timestampMatch = line.match(/\[(\d+) ms\]/);
                    const nodeMatch = line.match(/\[0x([0-9A-Fa-f]+)\]/);
                    
                    if (timestampMatch) {
                        const timestamp = parseInt(timestampMatch[1]);
                        const nodeId = nodeMatch ? nodeMatch[1] : 'unknown';
                        
                        // Parse slot transitions
                        const slotMatch = line.match(/Slot (\d+) transition: type=(\w+)/);
                        if (slotMatch) {
                            const slotNum = parseInt(slotMatch[1]);
                            const slotType = slotMatch[2];
                            
                            this.events.push({
                                timestamp,
                                nodeId,
                                type: 'slot_transition',
                                slotNum,
                                slotType
                            });
                        }

                        // Parse message transmissions - handle "Sending message" pattern first
                        const sendingMatch = line.match(/Sending message to 0x([0-9A-Fa-f]+), type: (\d+)/);
                        if (sendingMatch) {
                            const messageTypeInfo = getMessageTypeInfo(sendingMatch[2], 'transmitted');
                            
                            // Store pending transmission with type info
                            this.pendingTransmission = {
                                timestamp,
                                nodeId,
                                to: sendingMatch[1],
                                messageTypeInfo
                            };
                        }

                        // Parse "Transmitting message from X to Y" pattern - try multiple variations
                        let transmitMatch = line.match(/Transmitting message from 0x([0-9A-Fa-f]+) to 0x([0-9A-Fa-f]+)/);
                        if (!transmitMatch) {
                            // Try without "to X" part
                            transmitMatch = line.match(/Transmitting message from 0x([0-9A-Fa-f]+)/);
                            if (transmitMatch) {
                                transmitMatch[2] = 'FFFF'; // Default to broadcast if no "to" specified
                            }
                        }
                        
                        if (transmitMatch) {
                            let messageTypeInfo = { name: 'UNKNOWN', category: 'unknown', cssClass: 'tx' };
                            
                            // Use pending transmission info if available and matches
                            if (this.pendingTransmission && 
                                this.pendingTransmission.nodeId === nodeId &&
                                Math.abs(this.pendingTransmission.timestamp - timestamp) < 100) {
                                messageTypeInfo = this.pendingTransmission.messageTypeInfo;
                                this.pendingTransmission = null; // Clear pending transmission
                            }
                            
                            // Add transmission indicator on sender node
                            this.messages.push({
                                timestamp,
                                from: transmitMatch[1],
                                to: transmitMatch[2],
                                type: messageTypeInfo.cssClass,
                                typeName: messageTypeInfo.name,
                                category: messageTypeInfo.category,
                                nodeId: transmitMatch[1], // Node that sent the message
                                direction: 'transmitted'
                            });
                        }

                        // Parse message reception
                        const receiveMatch = line.match(/\*\*\* RECEIVED MESSAGE: type 0x([0-9A-Fa-f]+) from 0x([0-9A-Fa-f]+) to 0x([0-9A-Fa-f]+)/);
                        if (receiveMatch) {
                            const messageTypeInfo = getMessageTypeInfo('0x' + receiveMatch[1], 'received');
                            
                            // Add reception indicator on receiver node (use nodeId from timestamp line)
                            this.messages.push({
                                timestamp,
                                from: receiveMatch[2],
                                to: receiveMatch[3],
                                type: messageTypeInfo.cssClass,
                                typeName: messageTypeInfo.name,
                                category: messageTypeInfo.category,
                                nodeId: nodeId, // Use the node ID from the log line
                                direction: 'received'
                            });
                        }

                        // Parse additional message reception patterns
                        const receivedMatch = line.match(/received message from 0x([0-9A-Fa-f]+) to 0x([0-9A-Fa-f]+)/);
                        if (receivedMatch) {
                            // Try to infer message type from context
                            let messageTypeInfo = { name: 'UNKNOWN', category: 'unknown', cssClass: 'rx' };
                            
                            if (line.includes('sync beacon')) {
                                messageTypeInfo = getMessageTypeInfo(MessageType.SYNC_BEACON, 'received');
                            } else if (line.includes('Join request')) {
                                messageTypeInfo = getMessageTypeInfo(MessageType.JOIN_REQUEST, 'received');
                            } else if (line.includes('routing table')) {
                                messageTypeInfo = getMessageTypeInfo(MessageType.ROUTE_TABLE, 'received');
                            } else if (line.includes('control')) {
                                messageTypeInfo = { name: 'CONTROL', category: 'control', cssClass: 'control-rx' };
                            }
                            
                            // Add reception indicator on receiver node
                            this.messages.push({
                                timestamp,
                                from: receivedMatch[1],
                                to: receivedMatch[2],
                                type: messageTypeInfo.cssClass,
                                typeName: messageTypeInfo.name,
                                category: messageTypeInfo.category,
                                nodeId: receivedMatch[2], // Node that received the message
                                direction: 'received'
                            });
                        }

                        // Parse protocol states
                        const stateMatch = line.match(/Protocol task started|Network service configured|Starting LoRaMesh protocol/);
                        if (stateMatch) {
                            this.events.push({
                                timestamp,
                                nodeId,
                                type: 'protocol_event',
                                event: line.match(/\] (.+)$/)[1]
                            });
                        }

                        // Track nodes
                        if (nodeId !== 'unknown') {
                            if (!this.nodes.has(nodeId)) {
                                this.nodes.set(nodeId, {
                                    id: nodeId,
                                    firstSeen: timestamp,
                                    lastSeen: timestamp,
                                    slots: [],
                                    states: []
                                });
                            }
                            this.nodes.get(nodeId).lastSeen = timestamp;
                        }
                    }
                }

                // Calculate time range
                const allTimestamps = this.events.map(e => e.timestamp);
                this.timeRange.start = Math.min(...allTimestamps);
                this.timeRange.end = Math.max(...allTimestamps);

                console.log('Parsed log:', {
                    events: this.events,
                    messages: this.messages,
                    nodes: this.nodes,
                    timeRange: this.timeRange
                });
            }

            toggleFile(fileId) {
                const fileData = this.files.get(fileId);
                if (fileData) {
                    fileData.enabled = !fileData.enabled;
                    this.updateFileList();
                    this.aggregateData();
                    this.renderTimeline();
                    this.renderMessages();
                    this.renderStats();
                }
            }

            removeFile(fileId) {
                this.files.delete(fileId);
                this.updateFileList();
                this.aggregateData();
                if (this.files.size === 0) {
                    document.getElementById('visualizationContainer').style.display = 'none';
                } else {
                    this.renderTimeline();
                    this.renderMessages();
                    this.renderStats();
                }
            }

            async refreshFiles() {
                if (this.files.size === 0) {
                    console.log('‚ùå No files loaded');
                    return;
                }

                console.log('üîÑ Starting refresh process...');
                console.log(`üìÅ Total files to refresh: ${this.files.size}`);

                // Debug: Check what files we have
                this.files.forEach((fileData, fileId) => {
                    console.log(`üìÑ File: ${fileData.name}`);
                    console.log(`   - Has file object: ${!!fileData.file}`);
                    console.log(`   - Has file handle: ${!!fileData.fileHandle}`);
                    if (fileData.file) {
                        console.log(`   - Type: ${fileData.file.type || 'unknown'}`);
                        console.log(`   - Size: ${fileData.file.size} bytes`);
                        console.log(`   - Last modified: ${new Date(fileData.file.lastModified).toISOString()}`);
                    }
                });

                // Show loading indicator
                const logInfo = document.getElementById('logInfo');
                logInfo.innerHTML = '<strong>üîÑ Refreshing files...</strong>';
                logInfo.style.background = '#fff3cd';

                // Track refresh results
                const refreshResults = {
                    succeeded: [],
                    failed: [],
                    noFileObject: []
                };

                // Re-read all files
                let filesProcessed = 0;
                const totalFiles = this.files.size;
                const fileEntries = Array.from(this.files.entries());

                for (const [fileId, fileData] of fileEntries) {
                    // Try file handle first (true refresh!)
                    if (fileData.fileHandle) {
                        console.log(`üîë Using file handle to refresh ${fileData.name}...`);
                        try {
                            const file = await fileData.fileHandle.getFile();
                            console.log(`‚úÖ Got fresh file from handle: ${file.name} (${file.size} bytes, modified: ${new Date(file.lastModified).toISOString()})`);

                            // Read the fresh file
                            const text = await file.text();
                            fileData.content = text;
                            fileData.size = file.size;
                            fileData.file = file; // Update file object too

                            // Re-parse
                            this.parseLogFile(fileData);

                            refreshResults.succeeded.push(fileData.name);
                            filesProcessed++;
                            if (filesProcessed === totalFiles) {
                                this.finishRefresh(logInfo, refreshResults);
                            }
                        } catch (error) {
                            console.error(`‚ùå Error using file handle for ${fileData.name}:`, error);
                            refreshResults.failed.push({
                                name: fileData.name,
                                error: `Handle error: ${error.message}`
                            });
                            filesProcessed++;
                            if (filesProcessed === totalFiles) {
                                this.finishRefresh(logInfo, refreshResults);
                            }
                        }
                        continue;
                    }

                    // Fallback to old File object method
                    const file = fileData.file;
                    if (!file) {
                        console.warn(`‚ö†Ô∏è No file object stored for ${fileData.name}`);
                        refreshResults.noFileObject.push(fileData.name);
                        filesProcessed++;
                        if (filesProcessed === totalFiles) {
                            this.finishRefresh(logInfo, refreshResults);
                        }
                        continue;
                    }

                    const reader = new FileReader();

                    reader.onloadstart = () => {
                        console.log(`‚è≥ Started reading ${fileData.name}...`);
                    };

                    reader.onprogress = (e) => {
                        if (e.lengthComputable) {
                            console.log(`üìä Reading ${fileData.name}: ${e.loaded} / ${e.total} bytes`);
                        }
                    };

                    reader.onload = (e) => {
                        try {
                            console.log(`‚úÖ Successfully re-read ${fileData.name} (${file.size} bytes)`);

                            // Update the content
                            fileData.content = e.target.result;
                            fileData.size = file.size;

                            // Re-parse the file
                            this.parseLogFile(fileData);

                            refreshResults.succeeded.push(fileData.name);
                            filesProcessed++;
                            if (filesProcessed === totalFiles) {
                                this.finishRefresh(logInfo, refreshResults);
                            }
                        } catch (error) {
                            console.error(`‚ùå Error parsing ${fileData.name}:`, error);
                            console.error('Error stack:', error.stack);
                            refreshResults.failed.push({ name: fileData.name, error: error.message });
                            filesProcessed++;
                            if (filesProcessed === totalFiles) {
                                this.finishRefresh(logInfo, refreshResults);
                            }
                        }
                    };

                    reader.onerror = (event) => {
                        const errorDetails = reader.error ? reader.error.message : 'Unknown error';
                        const errorName = reader.error ? reader.error.name : 'Error';
                        console.error(`‚ùå FileReader error for ${fileData.name}:`, {
                            name: errorName,
                            message: errorDetails,
                            file: file.name,
                            fileSize: file.size,
                            fileType: file.type || 'unknown',
                            lastModified: new Date(file.lastModified).toISOString(),
                            readerReadyState: reader.readyState,
                            event: event
                        });
                        refreshResults.failed.push({
                            name: fileData.name,
                            error: `${errorName}: ${errorDetails}`
                        });
                        filesProcessed++;
                        if (filesProcessed === totalFiles) {
                            this.finishRefresh(logInfo, refreshResults);
                        }
                    };

                    reader.onabort = () => {
                        console.error(`‚ùå FileReader aborted for ${fileData.name}`);
                        refreshResults.failed.push({
                            name: fileData.name,
                            error: 'Read operation aborted'
                        });
                        filesProcessed++;
                        if (filesProcessed === totalFiles) {
                            this.finishRefresh(logInfo, refreshResults);
                        }
                    };

                    console.log(`üìÇ Attempting to refresh ${fileData.name}...`);
                    console.log(`   File object type: ${typeof file}`);
                    console.log(`   File is File instance: ${file instanceof File}`);
                    console.log(`   File is Blob instance: ${file instanceof Blob}`);

                    try {
                        reader.readAsText(file);
                        console.log(`   ‚úì readAsText() called successfully`);
                    } catch (error) {
                        console.error(`   ‚ùå Error calling readAsText():`, error);
                        refreshResults.failed.push({
                            name: fileData.name,
                            error: `readAsText failed: ${error.message}`
                        });
                        filesProcessed++;
                        if (filesProcessed === totalFiles) {
                            this.finishRefresh(logInfo, refreshResults);
                        }
                    }
                }
            }

            finishRefresh(logInfo, results) {
                // Re-aggregate and re-render everything (even with partial success)
                this.aggregateData();
                this.updateFileList();
                this.updateLogInfo();
                this.renderTimeline();
                this.renderMessages();
                this.renderStats();

                // Check if any failures are due to NotReadableError (locked files)
                const hasLockedFiles = results.failed.some(f => f.error.includes('NotReadableError'));

                // Determine success level and message
                const totalFiles = results.succeeded.length + results.failed.length + results.noFileObject.length;
                const hasFailures = results.failed.length > 0 || results.noFileObject.length > 0;

                if (!hasFailures) {
                    // Complete success
                    logInfo.style.background = '#d4edda';
                    logInfo.innerHTML = `<strong>‚úÖ Refresh complete!</strong> Successfully refreshed ${results.succeeded.length} file(s).`;

                    setTimeout(() => {
                        logInfo.style.background = '#e8f4f8';
                        this.updateLogInfo();
                    }, 2000);
                } else if (results.succeeded.length > 0) {
                    // Partial success
                    logInfo.style.background = '#fff3cd';
                    let message = `<strong>‚ö†Ô∏è Partial refresh:</strong> ${results.succeeded.length} succeeded, ${results.failed.length + results.noFileObject.length} failed.<br>`;

                    if (results.failed.length > 0) {
                        message += `<small>Failed files: ${results.failed.map(f => `${f.name} (${f.error})`).join(', ')}</small>`;
                    }
                    if (results.noFileObject.length > 0) {
                        message += `<small>No file reference: ${results.noFileObject.join(', ')}</small>`;
                    }

                    logInfo.innerHTML = message;

                    // Show refresh drop zone if locked files detected
                    if (hasLockedFiles) {
                        document.getElementById('refreshDropZone').classList.add('show');
                    }

                    setTimeout(() => {
                        logInfo.style.background = '#e8f4f8';
                        this.updateLogInfo();
                    }, 5000);
                } else {
                    // Complete failure
                    if (hasLockedFiles) {
                        // Locked files - this is expected, use friendlier message
                        logInfo.style.background = '#fff3cd';
                        let message = `<strong>üîÑ Refresh Requires File Access</strong><br>`;
                        message += `<small>For security, browsers require you to re-select files to refresh them.</small><br>`;
                        message += `<small>üëá Please drag your log files to the drop zone below to refresh.</small>`;
                        logInfo.innerHTML = message;

                        // Show the refresh drop zone
                        document.getElementById('refreshDropZone').classList.add('show');

                        // Keep message visible longer but not as an error
                        setTimeout(() => {
                            logInfo.style.background = '#e8f4f8';
                            this.updateLogInfo();
                        }, 15000);
                    } else {
                        // Other errors
                        logInfo.style.background = '#f8d7da';
                        let message = `<strong>‚ùå Refresh failed!</strong> All ${totalFiles} file(s) failed to refresh.<br>`;

                        if (results.failed.length > 0) {
                            message += `<small>Errors: ${results.failed.map(f => `${f.name} - ${f.error}`).join('; ')}</small><br>`;
                        }

                        message += `<small>üí° Tip: Try re-loading the files, or check if they're accessible.</small>`;

                        logInfo.innerHTML = message;

                        // Keep error visible longer
                        setTimeout(() => {
                            logInfo.style.background = '#e8f4f8';
                            this.updateLogInfo();
                        }, 10000);
                    }
                }

                // Log summary to console
                console.log('üìä Refresh Summary:', {
                    total: totalFiles,
                    succeeded: results.succeeded.length,
                    failed: results.failed.length,
                    noFileObject: results.noFileObject.length,
                    hasLockedFiles: hasLockedFiles,
                    details: results
                });
            }

            showVisualization() {
                document.getElementById('visualizationContainer').style.display = 'block';
                document.getElementById('timestampControls').style.display = 'block';
                this.updateLogInfo();
                this.renderTimeline();
                this.renderMessages();
                this.renderStats();
            }

            updateLogInfo() {
                const info = document.getElementById('logInfo');
                info.innerHTML = `
                    <strong>Log Analysis Results:</strong>
                    ${this.nodes.size} nodes detected, 
                    ${this.events.length} events parsed, 
                    ${this.messages.length} messages tracked,
                    Time range: ${this.formatTimestamp(this.timeRange.start)} - ${this.formatTimestamp(this.timeRange.end)}
                `;
            }

            renderTimeline() {
                const timelineContent = document.getElementById('timelineContent');
                timelineContent.innerHTML = '';

                // Initialize time window if not set
                if (this.timeWindowEnd === 0) {
                    this.timeWindowStart = this.timeRange.start;
                    this.timeWindowEnd = this.timeRange.end;
                }

                const windowDuration = this.timeWindowEnd - this.timeWindowStart;
                const totalDuration = this.timeRange.end - this.timeRange.start;
                
                // Calculate pixels per millisecond based on zoom level
                const basePixelsPerMs = 1200 / totalDuration;
                const pixelsPerMs = basePixelsPerMs * this.zoomLevel;
                
                // Set content width based on zoom
                const contentWidth = totalDuration * pixelsPerMs + 200;
                timelineContent.style.width = `${contentWidth}px`;

                this.nodes.forEach((node, nodeId) => {
                    const nodeDiv = document.createElement('div');
                    nodeDiv.className = 'node-timeline';
                    
                    const label = document.createElement('div');
                    label.className = 'node-label';
                    label.textContent = `Node 0x${nodeId}`;
                    nodeDiv.appendChild(label);

                    // Get slot events for this node
                    const nodeSlots = this.events.filter(e => 
                        e.nodeId === nodeId && e.type === 'slot_transition'
                    );

                    // Render individual slot transitions (don't group them)
                    nodeSlots.forEach((slot, index) => {
                        const nextSlot = nodeSlots[index + 1];
                        const slotEnd = nextSlot ? nextSlot.timestamp : slot.timestamp + 100; // Default 100ms if no next slot
                        
                        this.addSlotBar(nodeDiv, {
                            slotType: slot.slotType,
                            start: slot.timestamp,
                            end: slotEnd,
                            slotNum: slot.slotNum
                        }, pixelsPerMs);
                    });

                    // Render message indicators for this node
                    const nodeMessages = this.messages.filter(m => m.nodeId === nodeId);
                    nodeMessages.forEach(message => {
                        this.addMessageIndicator(nodeDiv, message, pixelsPerMs);
                    });

                    timelineContent.appendChild(nodeDiv);
                });

                // Update control labels
                this.updateControlLabels();
            }

            addSlotBar(nodeDiv, slot, pixelsPerMs) {
                const bar = document.createElement('div');
                bar.className = `slot-bar slot-${slot.slotType.toLowerCase()}`;
                
                const left = (slot.start - this.timeRange.start) * pixelsPerMs + 110;
                const width = Math.max(2, (slot.end - slot.start) * pixelsPerMs);
                
                bar.style.left = `${left}px`;
                bar.style.width = `${width}px`;
                
                // Only show text if width is sufficient
                if (width > 40) {
                    bar.textContent = `${slot.slotType} #${slot.slotNum}`;
                } else if (width > 20) {
                    bar.textContent = `#${slot.slotNum}`;
                }
                
                // Enhanced tooltip with detailed information
                const duration = slot.end - slot.start;
                const relativeTime = (slot.start - this.timeRange.start).toFixed(1);
                
                bar.title = `üî∏ Slot ${slot.slotNum}: ${slot.slotType}
üìÖ Start: ${this.formatTimestamp(slot.start)}
‚è±Ô∏è End: ${this.formatTimestamp(slot.end)}
‚è≥ Duration: ${duration}ms
üìä Relative: ${relativeTime}ms from start`;
                
                nodeDiv.appendChild(bar);
            }

            addMessageIndicator(nodeDiv, message, pixelsPerMs) {
                const indicator = document.createElement('div');
                indicator.className = `message-indicator message-${message.type}`;
                
                const left = (message.timestamp - this.timeRange.start) * pixelsPerMs + 110;
                const width = 3; // Fixed width for message indicators
                
                indicator.style.left = `${left}px`;
                indicator.style.width = `${width}px`;
                
                // Add message type indicator based on the actual message type name
                const typeMap = {
                    'tx': 'TX',
                    'rx': 'RX',
                    'beacon': 'B',
                    'control': 'C',
                    'join': 'J',
                    'routing': 'R',
                    'system': 'S',
                    'unknown': '?'
                };
                
                // Use the typeName if available, otherwise fall back to type
                let displayText = '?';
                if (message.typeName) {
                    // Create shorter display text from typeName
                    switch (message.typeName) {
                        case 'SYNC_BEACON': displayText = 'B'; break;
                        case 'JOIN_REQUEST': 
                        case 'JOIN_RESPONSE': displayText = 'J'; break;
                        case 'ROUTE_TABLE': displayText = 'R'; break;
                        case 'DATA': displayText = 'D'; break;
                        case 'ACK': displayText = 'A'; break;
                        case 'PING': displayText = 'P'; break;
                        case 'PONG': displayText = 'P'; break;
                        case 'HELLO': displayText = 'H'; break;
                        case 'SYNC': displayText = 'S'; break;
                        case 'SLOT_REQUEST': 
                        case 'SLOT_ALLOCATION': displayText = 'S'; break;
                        default: displayText = typeMap[message.type] || '?';
                    }
                } else {
                    displayText = typeMap[message.type] || '?';
                }
                if (width > 15) {
                    indicator.textContent = displayText;
                }
                
                // Enhanced tooltip with detailed message type information
                const direction = message.direction || 'unknown';
                const directionIcon = direction === 'transmitted' ? 'üì§' : 
                                    direction === 'received' ? 'üì•' : 'üìä';
                
                const typeName = message.typeName || message.type.toUpperCase();
                const category = message.category || 'unknown';
                
                const messageInfo = `üî∏ Message: ${typeName} (${category})
üìÖ Time: ${this.formatTimestamp(message.timestamp)}
üì§ From: 0x${message.from}
üì• To: 0x${message.to}
${directionIcon} Direction: ${direction}
üìÇ Category: ${category}
üìä Relative: ${(message.timestamp - this.timeRange.start).toFixed(1)}ms from start`;
                
                indicator.title = messageInfo;
                
                nodeDiv.appendChild(indicator);
            }

            updateControlLabels() {
                const zoomLevelSpan = document.getElementById('zoomLevel');
                const timeRangeLabel = document.getElementById('timeRangeLabel');
                const timeRangeSlider = document.getElementById('timeRangeSlider');
                
                if (zoomLevelSpan) {
                    zoomLevelSpan.textContent = `${this.zoomLevel}x`;
                }
                
                if (timeRangeLabel) {
                    timeRangeLabel.textContent = `${this.formatTimestamp(this.timeWindowStart)} - ${this.formatTimestamp(this.timeWindowEnd)}`;
                }
                
                if (timeRangeSlider) {
                    const totalDuration = this.timeRange.end - this.timeRange.start;
                    const windowDuration = this.timeWindowEnd - this.timeWindowStart;
                    const maxStart = totalDuration - windowDuration;
                    const currentStart = this.timeWindowStart - this.timeRange.start;
                    
                    timeRangeSlider.max = maxStart;
                    timeRangeSlider.value = currentStart;
                }
            }

            renderMessages() {
                const messageFlow = document.getElementById('messageFlow');
                messageFlow.innerHTML = '';

                this.messages.forEach(msg => {
                    const msgDiv = document.createElement('div');
                    msgDiv.className = 'message-item';
                    
                    const direction = msg.direction || 'unknown';
                    const directionIcon = direction === 'transmitted' ? 'üì§' : 
                                        direction === 'received' ? 'üì•' : 'üìä';
                    
                    const typeName = msg.typeName || msg.type.toUpperCase();
                    const category = msg.category || 'unknown';
                    const categoryIcon = {
                        'data': 'üìä',
                        'control': '‚öôÔ∏è',
                        'routing': 'üó∫Ô∏è',
                        'system': 'üîß',
                        'unknown': '‚ùì'
                    }[category] || '‚ùì';
                    
                    msgDiv.innerHTML = `
                        <div class="message-time">${this.formatTimestamp(msg.timestamp)}</div>
                        <div class="message-content">
                            <span class="message-from">0x${msg.from}</span> 
                            ‚Üí 
                            <span class="message-to">0x${msg.to}</span>
                            <span style="margin-left: 10px; color: #2c3e50; font-weight: bold;">${typeName}</span>
                            <span style="margin-left: 5px; color: #7f8c8d;">${categoryIcon} ${category}</span>
                            <span style="margin-left: 5px; color: #7f8c8d;">${directionIcon} ${direction}</span>
                        </div>
                    `;
                    
                    messageFlow.appendChild(msgDiv);
                });
            }

            renderStats() {
                const statsGrid = document.getElementById('statsGrid');
                statsGrid.innerHTML = '';

                const stats = [
                    { label: 'Total Nodes', value: this.nodes.size },
                    { label: 'Total Events', value: this.events.length },
                    { label: 'Messages Sent', value: this.messages.length },
                    { label: 'Duration (ms)', value: this.timeRange.end - this.timeRange.start }
                ];

                stats.forEach(stat => {
                    const card = document.createElement('div');
                    card.className = 'stat-card';
                    card.innerHTML = `
                        <div class="stat-value">${stat.value}</div>
                        <div class="stat-label">${stat.label}</div>
                    `;
                    statsGrid.appendChild(card);
                });
            }

            showError(message) {
                const error = document.createElement('div');
                error.className = 'error';
                error.textContent = message;
                document.querySelector('.container').insertBefore(error, document.querySelector('.upload-section'));
            }
        }

        function showTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
        }

        // Initialize the analyzer
        const analyzer = new LogAnalyzer();

        // File selection function
        async function selectFiles() {
            if (analyzer.supportsFileSystemAccess) {
                // Use File System Access API for true refresh support
                await analyzer.selectFilesWithPicker();
            } else {
                // Fall back to traditional file input
                document.getElementById('fileInput').click();
            }
        }

        // Zoom control functions
        function zoomIn() {
            const zoomSlider = document.getElementById('zoomSlider');
            const newValue = Math.min(100, parseInt(zoomSlider.value) + 5);
            zoomSlider.value = newValue;
            updateZoom();
        }

        function zoomOut() {
            const zoomSlider = document.getElementById('zoomSlider');
            const newValue = Math.max(1, parseInt(zoomSlider.value) - 5);
            zoomSlider.value = newValue;
            updateZoom();
        }

        function updateZoom() {
            const zoomSlider = document.getElementById('zoomSlider');
            analyzer.zoomLevel = parseInt(zoomSlider.value);
            analyzer.renderTimeline();
        }

        function updateTimeRange() {
            const timeRangeSlider = document.getElementById('timeRangeSlider');
            const totalDuration = analyzer.timeRange.end - analyzer.timeRange.start;
            const windowDuration = totalDuration / analyzer.zoomLevel;
            const sliderValue = parseInt(timeRangeSlider.value);
            
            analyzer.timeWindowStart = analyzer.timeRange.start + sliderValue;
            analyzer.timeWindowEnd = analyzer.timeWindowStart + windowDuration;
            
            analyzer.renderTimeline();
        }

        function resetView() {
            const zoomSlider = document.getElementById('zoomSlider');
            const timeRangeSlider = document.getElementById('timeRangeSlider');
            
            zoomSlider.value = 10;
            timeRangeSlider.value = 0;
            
            analyzer.zoomLevel = 10;
            analyzer.timeWindowStart = analyzer.timeRange.start;
            analyzer.timeWindowEnd = analyzer.timeRange.end;
            
            analyzer.renderTimeline();
        }

        async function refreshFiles() {
            await analyzer.refreshFiles();
        }

        function clearAllFiles() {
            analyzer.files.clear();
            analyzer.updateFileList();
            document.getElementById('visualizationContainer').style.display = 'none';
        }

        function toggleAllFiles() {
            const allEnabled = Array.from(analyzer.files.values()).every(file => file.enabled);
            analyzer.files.forEach(file => {
                file.enabled = !allEnabled;
            });
            analyzer.updateFileList();
            analyzer.aggregateData();
            analyzer.renderTimeline();
            analyzer.renderMessages();
            analyzer.renderStats();
        }

        function toggleTimestampFormat() {
            const selectedFormat = document.querySelector('input[name="timestampFormat"]:checked').value;
            analyzer.timestampFormat = selectedFormat;

            // Re-render everything with new timestamp format
            analyzer.updateLogInfo();
            analyzer.renderTimeline();
            analyzer.renderMessages();
            analyzer.updateControlLabels();
        }

        function toggleLegend() {
            const content = document.getElementById('legendContent');
            const icon = document.getElementById('toggleIcon');
            
            if (content.classList.contains('show')) {
                content.classList.remove('show');
                icon.classList.remove('rotated');
                icon.textContent = '‚ñº';
            } else {
                content.classList.add('show');
                icon.classList.add('rotated');
                icon.textContent = '‚ñ≤';
            }
        }
    </script>
</body>
</html>